==================================================
FILE: ./next-env.d.ts
==================================================
/// <reference types="next" />
/// <reference types="next/image-types/global" />
/// <reference path="./.next/types/routes.d.ts" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.



==================================================
FILE: ./next.config.ts
==================================================
import type { NextConfig } from 'next';

const nextConfig: NextConfig = {
  reactStrictMode: true,
  // Allow external images if needed
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: '**',
      },
    ],
  },
};

export default nextConfig;



==================================================
FILE: ./package.json
==================================================
{
  "name": "claude-coder",
  "version": "2.0.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@anthropic-ai/sdk": "^0.52.0",
    "lucide-react": "^0.468.0",
    "next": "^15.1.0",
    "octokit": "^4.0.2",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-markdown": "^9.0.1",
    "react-syntax-highlighter": "^15.6.1"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4.0.0",
    "@types/node": "^22.10.2",
    "@types/react": "^19.0.1",
    "@types/react-dom": "^19.0.1",
    "@types/react-syntax-highlighter": "^15.5.13",
    "tailwindcss": "^4.0.0",
    "typescript": "^5.7.2"
  }
}



==================================================
FILE: ./src/app/api/auth/route.ts
==================================================
// ============================================================================
// AUTH API ROUTE - Password auth + API key validation
// ============================================================================

import { NextRequest, NextResponse } from 'next/server';
import Anthropic from '@anthropic-ai/sdk';
import { Octokit } from 'octokit';

// Password authentication endpoint
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { action, password, anthropicKey, githubToken } = body;

    // Handle password login
    if (action === 'login') {
      const appPassword = process.env.APP_PASSWORD;

      // If no APP_PASSWORD is set, allow access (for development)
      if (!appPassword) {
        return NextResponse.json({
          success: true,
          message: 'No password configured - access granted',
          noPasswordSet: true,
        });
      }

      if (password === appPassword) {
        return NextResponse.json({ success: true });
      } else {
        return NextResponse.json({
          success: false,
          error: 'Invalid password'
        }, { status: 401 });
      }
    }

    // Handle API key validation
    if (action === 'validate') {
      const results: {
        anthropic: { valid: boolean; error?: string };
        github: { valid: boolean; user?: string; error?: string };
      } = {
        anthropic: { valid: false },
        github: { valid: false },
      };

      // Validate Anthropic key
      if (anthropicKey) {
        try {
          const client = new Anthropic({ apiKey: anthropicKey });
          // Make a minimal API call to verify
          await client.messages.create({
            model: 'claude-haiku-4-5-20251001',
            max_tokens: 1,
            messages: [{ role: 'user', content: 'hi' }],
          });
          results.anthropic.valid = true;
        } catch (error) {
          results.anthropic.error = error instanceof Error ? error.message : 'Invalid key';
        }
      }

      // Validate GitHub token (optional)
      if (githubToken) {
        try {
          const octokit = new Octokit({ auth: githubToken });
          const { data } = await octokit.rest.users.getAuthenticated();
          results.github.valid = true;
          results.github.user = data.login;
        } catch (error) {
          results.github.error = error instanceof Error ? error.message : 'Invalid token';
        }
      }

      return NextResponse.json(results);
    }

    // Legacy support: validate both keys (old format)
    if (anthropicKey || githubToken) {
      const results: {
        anthropic: { valid: boolean; error?: string };
        github: { valid: boolean; user?: string; error?: string };
      } = {
        anthropic: { valid: false },
        github: { valid: false },
      };

      if (anthropicKey) {
        try {
          const client = new Anthropic({ apiKey: anthropicKey });
          await client.messages.create({
            model: 'claude-haiku-4-5-20251001',
            max_tokens: 1,
            messages: [{ role: 'user', content: 'hi' }],
          });
          results.anthropic.valid = true;
        } catch (error) {
          results.anthropic.error = error instanceof Error ? error.message : 'Invalid key';
        }
      }

      if (githubToken) {
        try {
          const octokit = new Octokit({ auth: githubToken });
          const { data } = await octokit.rest.users.getAuthenticated();
          results.github.valid = true;
          results.github.user = data.login;
        } catch (error) {
          results.github.error = error instanceof Error ? error.message : 'Invalid token';
        }
      }

      return NextResponse.json(results);
    }

    return NextResponse.json({ error: 'Invalid request' }, { status: 400 });

  } catch (error) {
    console.error('Auth error:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json({ error: message }, { status: 500 });
  }
}

// GET - List user's repositories
export async function GET(request: NextRequest) {
  try {
    const githubToken = request.headers.get('x-github-token');
    if (!githubToken) {
      return NextResponse.json({ error: 'GitHub token required' }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const type = searchParams.get('type') || 'all';
    const sort = searchParams.get('sort') || 'updated';
    const perPage = parseInt(searchParams.get('per_page') || '30');

    const octokit = new Octokit({ auth: githubToken });
    
    const { data: repos } = await octokit.rest.repos.listForAuthenticatedUser({
      type: type as 'all' | 'owner' | 'public' | 'private' | 'member',
      sort: sort as 'created' | 'updated' | 'pushed' | 'full_name',
      per_page: perPage,
    });

    return NextResponse.json({
      repos: repos.map(repo => ({
        owner: repo.owner.login,
        name: repo.name,
        fullName: repo.full_name,
        defaultBranch: repo.default_branch,
        isPrivate: repo.private,
        updatedAt: repo.updated_at,
        language: repo.language,
      })),
    });

  } catch (error) {
    console.error('List repos error:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json({ error: message }, { status: 500 });
  }
}



==================================================
FILE: ./src/app/api/chat/route.ts
==================================================
// ============================================================================
// CHAT API ROUTE - Main endpoint for Claude interactions
// ============================================================================

import { NextRequest, NextResponse } from 'next/server';
import { ClaudeClient, getSystemPrompt, generateCodeContext, extractKeywords } from '@/lib/claude';
import { GitHubClient, formatFileTree } from '@/lib/github';
import { ChatRequest, Settings, RepoFile, FileChange, TokenUsage } from '@/types';

// Store for session-based file tree caching
const fileTreeCache = new Map<string, { tree: string; timestamp: number }>();
const CACHE_TTL = 5 * 60 * 1000; // 5 minutes

export async function POST(request: NextRequest) {
  try {
    const body = await request.json() as ChatRequest;
    const { settings, repoContext, files } = body;

    // Filter out any empty messages to satisfy Anthropic API validation
    const messages = body.messages.filter(m => m.content?.trim());

    // Validate required API keys
    const anthropicKey = request.headers.get('x-anthropic-key');
    const githubToken = request.headers.get('x-github-token');

    if (!anthropicKey) {
      return NextResponse.json(
        { error: 'Anthropic API key required' },
        { status: 401 }
      );
    }

    if (!githubToken) {
      return NextResponse.json(
        { error: 'GitHub token required' },
        { status: 401 }
      );
    }

    // Initialize clients
    const claude = new ClaudeClient(anthropicKey, settings.model);
    const github = new GitHubClient(githubToken, repoContext.owner, repoContext.repo);

    // Get or cache file tree
    const cacheKey = `${repoContext.owner}/${repoContext.repo}/${repoContext.branch}`;
    let fileTree = repoContext.fileTree || '';

    if (!fileTree) {
      const cached = fileTreeCache.get(cacheKey);
      if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
        fileTree = cached.tree;
      } else {
        const tree = await github.getFileTree(repoContext.branch);
        fileTree = formatFileTree(tree);
        fileTreeCache.set(cacheKey, { tree: fileTree, timestamp: Date.now() });
      }
    }

    // Smart file loading based on keywords
    let loadedFiles: RepoFile[] = repoContext.loadedFiles || [];
    
    if (loadedFiles.length === 0 && messages.length > 0) {
      const lastUserMessage = messages[messages.length - 1];
      if (lastUserMessage.role === 'user') {
        const keywords = extractKeywords(lastUserMessage.content);
        
        if (keywords.length > 0) {
          // Try to find relevant files
          const searchPromises = keywords.slice(0, 3).map(kw => 
            github.searchFiles(kw).catch(() => [])
          );
          const searchResults = await Promise.all(searchPromises);
          const uniquePaths = [...new Set(searchResults.flat())].slice(0, 5);
          
          if (uniquePaths.length > 0) {
            loadedFiles = await github.getFilesWithImports(uniquePaths, repoContext.branch, 2);
          }
        }
      }
    }

    // Generate code context
    const codeContext = generateCodeContext(fileTree, loadedFiles);

    // Get system prompt
    const systemPrompt = getSystemPrompt(
      repoContext.owner,
      repoContext.repo,
      repoContext.branch,
      settings.enableWebSearch
    );

    // Build tools array
    const tools = claude['getDefaultTools']();
    if (settings.enableWebSearch) {
      tools.push(claude.getWebSearchTool());
      tools.push(claude.getWebFetchTool());
    }

    // Prepare messages with file uploads if any
    const apiMessages = messages.map(m => {
      if (m.role === 'user' && files && files.length > 0) {
        // Include file content in the message
        const fileContent = files.map(f => 
          `\n\n[Attached file: ${f.name}]\n${atob(f.base64)}`
        ).join('');
        return { role: m.role, content: m.content + fileContent };
      }
      return { role: m.role, content: m.content };
    });

    // Call Claude
    const response = await claude.chat(
      apiMessages,
      systemPrompt,
      codeContext,
      {
        tools,
        enableThinking: settings.enableExtendedThinking,
        thinkingBudget: settings.thinkingBudget,
        effort: settings.effort,
        enableCodeExecution: settings.enableCodeExecution,
        enableMemory: settings.enableMemory,
        enableContextCompaction: settings.enableContextCompaction,
        enableInterleavedThinking: settings.enableInterleavedThinking,
      }
    );

    // Process tool calls if any
    let fileChanges: FileChange[] = [];
    
    if (response.toolCalls) {
      for (const toolCall of response.toolCalls) {
        if (toolCall.name === 'str_replace') {
          const input = toolCall.input as { path: string; old_str: string; new_str: string };
          const result = await github.applyStrReplace(
            input.path,
            input.old_str,
            input.new_str,
            repoContext.branch
          );
          
          if (result.success) {
            fileChanges.push({
              path: input.path,
              action: 'edit',
              additions: result.additions,
              deletions: result.deletions,
            });
          }
        } else if (toolCall.name === 'create_file') {
          const input = toolCall.input as { path: string; content: string };
          const result = await github.createFile(
            input.path,
            input.content,
            repoContext.branch
          );
          
          if (result.success) {
            fileChanges.push({
              path: input.path,
              action: 'create',
              additions: result.additions,
            });
          }
        } else if (toolCall.name === 'read_file') {
          const input = toolCall.input as { path: string };
          try {
            const file = await github.getFileContent(input.path, repoContext.branch);
            loadedFiles.push(file);
          } catch {
            // File not found
          }
        }
      }
    }

    return NextResponse.json({
      content: response.content,
      toolCalls: response.toolCalls,
      usage: response.usage,
      cost: response.cost,
      savedPercent: response.savedPercent,
      thinkingContent: response.thinkingContent,
      artifacts: response.artifacts,
      citations: response.citations,
      fileChanges: fileChanges.length > 0 ? fileChanges : undefined,
      loadedFiles: loadedFiles.map(f => f.path),
    });

  } catch (error) {
    console.error('Chat API error:', error);
    
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { error: message },
      { status: 500 }
    );
  }
}

// Streaming endpoint - FIXED: Execute tools ONCE per message (NO LOOP!)
// This reduces cost from $1+ to ~$0.03 per message
export async function PUT(request: NextRequest) {
  try {
    const body = await request.json() as ChatRequest;
    const { settings, repoContext } = body;

    // Filter out any empty messages to avoid Anthropic validation errors
    const messages = body.messages.filter(m => m.content?.trim());

    const anthropicKey = request.headers.get('x-anthropic-key');
    const githubToken = request.headers.get('x-github-token');

    if (!anthropicKey) {
      return NextResponse.json(
        { error: 'Anthropic API key required' },
        { status: 401 }
      );
    }

    const claude = new ClaudeClient(anthropicKey, settings.model);

    // GitHub client is optional - only create if we have context
    const hasRepoContext = repoContext && repoContext.owner && repoContext.repo;
    const github = hasRepoContext && githubToken
      ? new GitHubClient(githubToken, repoContext.owner, repoContext.repo)
      : null;

    // Only load file context if we have a repo
    let fileTree = '';
    let loadedFiles: RepoFile[] = [];

    if (github && hasRepoContext) {
      // Check cache first
      const cacheKey = `${repoContext.owner}/${repoContext.repo}/${repoContext.branch}`;
      const cached = fileTreeCache.get(cacheKey);

      if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
        fileTree = cached.tree;
      } else {
        const tree = await github.getFileTree(repoContext.branch);
        fileTree = formatFileTree(tree);
        fileTreeCache.set(cacheKey, { tree: fileTree, timestamp: Date.now() });
      }

      // Smart file loading based on keywords
      const lastMessage = messages[messages.length - 1];
      if (lastMessage?.role === 'user') {
        const keywords = extractKeywords(lastMessage.content);
        if (keywords.length > 0) {
          const paths = await github.searchFiles(keywords[0]).catch(() => []);
          if (paths.length > 0) {
            loadedFiles = await github.getFilesWithImports(paths.slice(0, 3), repoContext.branch, 2);
          }
        }
      }
    }

    // Generate context (empty string if no repo)
    const codeContext = hasRepoContext
      ? generateCodeContext(fileTree, loadedFiles)
      : '';

    const systemPrompt = hasRepoContext
      ? getSystemPrompt(
          repoContext.owner,
          repoContext.repo,
          repoContext.branch,
          settings.enableWebSearch
        )
      : getChatOnlySystemPrompt(settings.enableWebSearch);

    // Build tools array - only include repo tools if we have a repo
    const tools = hasRepoContext ? claude.getDefaultTools() : [];
    if (settings.enableWebSearch) {
      tools.push(claude.getWebSearchTool());
      tools.push(claude.getWebFetchTool());
    }

    // Create streaming response - SINGLE PASS, NO LOOP!
    const encoder = new TextEncoder();
    const stream = new ReadableStream({
      async start(controller) {
        try {
          const pendingToolCalls: Array<{ id: string; name: string; input: Record<string, unknown> }> = [];

          // Stream Claude's response (SINGLE API CALL)
          const streamGenerator = claude.streamChat(
            messages,
            systemPrompt,
            codeContext,
            {
              tools: tools.length > 0 ? tools : undefined,
              enableThinking: settings.enableExtendedThinking,
              thinkingBudget: settings.thinkingBudget,
              effort: settings.effort,
              enableContextCompaction: settings.enableContextCompaction,
              enableInterleavedThinking: settings.enableInterleavedThinking,
            }
          );

          let totalCost = 0;
          let totalSavedPercent = 0;

          for await (const chunk of streamGenerator) {
            // Forward all chunks to client for real-time display
            controller.enqueue(encoder.encode(JSON.stringify(chunk) + '\n'));

            // Collect tool calls for execution AFTER streaming
            if (chunk.type === 'tool_use' && chunk.toolCall) {
              pendingToolCalls.push({
                id: chunk.toolCall.id,
                name: chunk.toolCall.name,
                input: chunk.toolCall.input,
              });
            } else if (chunk.type === 'done') {
              totalCost = chunk.cost || 0;
              totalSavedPercent = chunk.savedPercent || 0;
            }
          }

          // Execute tools ONCE after streaming (NOT in a loop!)
          // User sends next message if they need Claude to continue
          const fileChanges: FileChange[] = [];

          for (const toolCall of pendingToolCalls) {
            let result = '';

            try {
              if (toolCall.name === 'read_file' && github) {
                const input = toolCall.input as { path: string };
                const file = await github.getFileContent(input.path, repoContext.branch);
                result = `File content loaded (${file.content.length} chars)`;
              } else if (toolCall.name === 'search_files' && github) {
                const input = toolCall.input as { query: string };
                const paths = await github.searchFiles(input.query);
                result = paths.length > 0
                  ? `Found ${paths.length} files:\n${paths.join('\n')}`
                  : 'No files found matching the query.';
              } else if (toolCall.name === 'grep_search' && github) {
                const input = toolCall.input as { pattern: string };
                const matches = await github.grepSearch(input.pattern, repoContext.branch, {});
                result = matches.length > 0
                  ? matches.map(m => `${m.path}:${m.line}: ${m.content}`).join('\n')
                  : 'No matches found.';
              } else if (toolCall.name === 'str_replace' && github) {
                const input = toolCall.input as { path: string; old_str: string; new_str: string };
                const replaceResult = await github.applyStrReplace(
                  input.path,
                  input.old_str,
                  input.new_str,
                  repoContext.branch
                );
                if (replaceResult.success) {
                  result = `Successfully replaced text in ${input.path}. Changes: +${replaceResult.additions} -${replaceResult.deletions}`;
                  fileChanges.push({
                    path: input.path,
                    action: 'edit',
                    additions: replaceResult.additions,
                    deletions: replaceResult.deletions,
                  });
                } else {
                  result = `Failed to replace: ${replaceResult.error || 'Unknown error'}`;
                }
              } else if (toolCall.name === 'create_file' && github) {
                const input = toolCall.input as { path: string; content: string };
                const createResult = await github.createFile(
                  input.path,
                  input.content,
                  repoContext.branch
                );
                if (createResult.success) {
                  result = `Successfully created ${input.path}`;
                  fileChanges.push({
                    path: input.path,
                    action: 'create',
                    additions: createResult.additions,
                  });
                } else {
                  result = `Failed to create file: ${createResult.error || 'Unknown error'}`;
                }
              } else {
                result = `Tool ${toolCall.name} executed`;
              }
            } catch (error) {
              result = `Error: ${error instanceof Error ? error.message : 'Unknown error'}`;
            }

            // Stream tool result to client
            controller.enqueue(encoder.encode(JSON.stringify({
              type: 'tool_result',
              toolUseId: toolCall.id,
              name: toolCall.name,
              result: result.slice(0, 1000) + (result.length > 1000 ? '...(truncated)' : ''),
            }) + '\n'));
          }

          // Send final done event with cost info
          controller.enqueue(encoder.encode(JSON.stringify({
            type: 'done',
            cost: totalCost,
            savedPercent: totalSavedPercent,
            fileChanges: fileChanges.length > 0 ? fileChanges : undefined,
          }) + '\n'));

          controller.close();
        } catch (error) {
          const message = error instanceof Error ? error.message : 'Stream error';
          controller.enqueue(encoder.encode(JSON.stringify({ error: message }) + '\n'));
          controller.close();
        }
      },
    });

    return new Response(stream, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
      },
    });

  } catch (error) {
    console.error('Stream API error:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json({ error: message }, { status: 500 });
  }
}

// System prompt for chat-only mode (no repo)
function getChatOnlySystemPrompt(enableWebSearch: boolean): string {
  const tools = enableWebSearch ? ['web_search', 'web_fetch'] : [];
  return `You are Claude, an AI assistant by Anthropic.
${tools.length > 0 ? `\nAvailable tools: ${tools.join(', ')}` : ''}

You can help with:
- Answering questions
- Writing and explaining code
- Analysis and reasoning
- Creative writing
- And much more

If the user wants to connect a GitHub repository for code editing, let them know they can select one from the repository dropdown.`;
}



==================================================
FILE: ./src/app/api/github/route.ts
==================================================
// ============================================================================
// GITHUB API ROUTE - Branch, PR, and file operations
// ============================================================================

import { NextRequest, NextResponse } from 'next/server';
import { GitHubClient } from '@/lib/github';

// GET - List repos, branches, files, etc.
export async function GET(request: NextRequest) {
  try {
    const githubToken = request.headers.get('x-github-token');
    if (!githubToken) {
      return NextResponse.json({ error: 'GitHub token required' }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const action = searchParams.get('action');
    const owner = searchParams.get('owner') || '';
    const repo = searchParams.get('repo') || '';
    const branch = searchParams.get('branch') || 'main';
    const path = searchParams.get('path') || '';

    if (!owner || !repo) {
      return NextResponse.json({ error: 'Owner and repo required' }, { status: 400 });
    }

    const github = new GitHubClient(githubToken, owner, repo);

    switch (action) {
      case 'branches': {
        const branches = await github.listBranches();
        return NextResponse.json({ branches });
      }

      case 'tree': {
        const tree = await github.getFileTree(branch);
        return NextResponse.json({ tree });
      }

      case 'file': {
        if (!path) {
          return NextResponse.json({ error: 'Path required' }, { status: 400 });
        }
        const file = await github.getFileContent(path, branch);
        return NextResponse.json({ file });
      }

      case 'search': {
        const query = searchParams.get('query') || '';
        if (!query) {
          return NextResponse.json({ error: 'Query required' }, { status: 400 });
        }
        const results = await github.searchFiles(query);
        return NextResponse.json({ results });
      }

      case 'grep': {
        const query = searchParams.get('query') || '';
        if (!query) {
          return NextResponse.json({ error: 'Query required' }, { status: 400 });
        }
        const extensions = searchParams.get('extensions')?.split(',');
        const results = await github.grepSearch(query, branch, { fileExtensions: extensions });
        return NextResponse.json({ results });
      }

      case 'repo': {
        const repoInfo = await github.getRepository();
        return NextResponse.json({ repo: repoInfo });
      }

      case 'commits': {
        const count = parseInt(searchParams.get('count') || '10');
        const commits = await github.getRecentCommits(branch, count);
        return NextResponse.json({ commits });
      }

      default:
        return NextResponse.json({ error: 'Invalid action' }, { status: 400 });
    }

  } catch (error) {
    console.error('GitHub GET error:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json({ error: message }, { status: 500 });
  }
}

// POST - Create branches, PRs, files
export async function POST(request: NextRequest) {
  try {
    const githubToken = request.headers.get('x-github-token');
    if (!githubToken) {
      return NextResponse.json({ error: 'GitHub token required' }, { status: 401 });
    }

    const body = await request.json();
    const { action, owner, repo, ...params } = body;

    if (!owner || !repo) {
      return NextResponse.json({ error: 'Owner and repo required' }, { status: 400 });
    }

    const github = new GitHubClient(githubToken, owner, repo);

    switch (action) {
      case 'createBranch': {
        const { branchName, fromBranch } = params;
        if (!branchName) {
          return NextResponse.json({ error: 'Branch name required' }, { status: 400 });
        }
        const branch = await github.createBranch(branchName, fromBranch || 'main');
        return NextResponse.json({ branch });
      }

      case 'deleteBranch': {
        const { branch } = params;
        if (!branch) {
          return NextResponse.json({ error: 'Branch required' }, { status: 400 });
        }
        await github.deleteBranch(branch);
        return NextResponse.json({ success: true });
      }

      case 'createFile': {
        const { path, content, branch } = params;
        if (!path || content === undefined) {
          return NextResponse.json({ error: 'Path and content required' }, { status: 400 });
        }
        const result = await github.createFile(path, content, branch || 'main');
        return NextResponse.json(result);
      }

      case 'updateFile': {
        const { path, content, message, branch, sha } = params;
        if (!path || content === undefined) {
          return NextResponse.json({ error: 'Path and content required' }, { status: 400 });
        }
        await github.updateFile(path, content, message || `Update ${path}`, branch || 'main', sha);
        return NextResponse.json({ success: true });
      }

      case 'strReplace': {
        const { path, oldStr, newStr, branch } = params;
        if (!path || oldStr === undefined || newStr === undefined) {
          return NextResponse.json({ error: 'Path, oldStr, and newStr required' }, { status: 400 });
        }
        const result = await github.applyStrReplace(path, oldStr, newStr, branch || 'main');
        return NextResponse.json(result);
      }

      case 'createPR': {
        const { title, body, head, base } = params;
        if (!title || !head) {
          return NextResponse.json({ error: 'Title and head branch required' }, { status: 400 });
        }
        const pr = await github.createPullRequest(title, body || '', head, base || 'main');
        return NextResponse.json({ pr });
      }

      case 'getPR': {
        const { prNumber } = params;
        if (!prNumber) {
          return NextResponse.json({ error: 'PR number required' }, { status: 400 });
        }
        const pr = await github.getPullRequest(prNumber);
        return NextResponse.json({ pr });
      }

      default:
        return NextResponse.json({ error: 'Invalid action' }, { status: 400 });
    }

  } catch (error) {
    console.error('GitHub POST error:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json({ error: message }, { status: 500 });
  }
}



==================================================
FILE: ./src/app/globals.css
==================================================
@import url('https://fonts.googleapis.com/css2?family=Source+Serif+4:ital,opsz,wght@0,8..60,400;0,8..60,500;0,8..60,600;1,8..60,400&family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400;500&display=swap');
@import "tailwindcss";

/* Claude-Inspired Premium Design System */

:root {
  --claude-bg: #FAF9F7;
  --claude-bg-warm: #F5F2ED;
  --claude-surface: #FFFFFF;
  --claude-surface-elevated: #FFFFFF;
  --claude-surface-sunken: #F7F5F2;
  --claude-border: rgba(207, 198, 185, 0.4);
  --claude-border-strong: rgba(207, 198, 185, 0.7);
  --claude-terracotta: #DA7756;
  --claude-terracotta-hover: #C96847;
  --claude-terracotta-subtle: rgba(218, 119, 86, 0.1);
  --claude-terracotta-glow: rgba(218, 119, 86, 0.15);
  --claude-sand: #E6DFD4;
  --claude-sand-light: #F0EBE3;
  --claude-cream: #FAF7F2;
  --claude-text: #1F1F1E;
  --claude-text-secondary: #5C5C5A;
  --claude-text-muted: #9A9A98;
  --claude-text-faint: #BDBDBB;
  --claude-success: #4A9D6E;
  --claude-warning: #D4A843;
  --claude-error: #C75D5D;
  --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.04), 0 1px 2px rgba(0, 0, 0, 0.02);
  --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.05), 0 2px 4px rgba(0, 0, 0, 0.02);
  --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.06), 0 4px 8px rgba(0, 0, 0, 0.03);
  --shadow-glow: 0 0 0 3px var(--claude-terracotta-glow);
  --shadow-card: 0 2px 8px rgba(0, 0, 0, 0.04), 0 0 0 1px rgba(0, 0, 0, 0.02);
  --ease-out-expo: cubic-bezier(0.16, 1, 0.3, 1);
  --ease-out-quad: cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

.dark {
  --claude-bg: #1A1918;
  --claude-bg-warm: #222120;
  --claude-surface: #2A2928;
  --claude-surface-elevated: #323130;
  --claude-surface-sunken: #151414;
  --claude-border: rgba(255, 255, 255, 0.08);
  --claude-border-strong: rgba(255, 255, 255, 0.15);
  --claude-terracotta: #E08B6D;
  --claude-terracotta-hover: #EA9E82;
  --claude-terracotta-subtle: rgba(224, 139, 109, 0.12);
  --claude-terracotta-glow: rgba(224, 139, 109, 0.2);
  --claude-sand: #3D3A36;
  --claude-sand-light: #2F2D2A;
  --claude-cream: #252422;
  --claude-text: #F5F4F2;
  --claude-text-secondary: #B8B6B2;
  --claude-text-muted: #7A7875;
  --claude-text-faint: #5A5856;
  --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.3);
  --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.4);
  --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.5);
  --shadow-card: 0 2px 8px rgba(0, 0, 0, 0.3), 0 0 0 1px rgba(255, 255, 255, 0.05);
}

* { box-sizing: border-box; }

html {
  font-size: 16px;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
  background: var(--claude-bg);
  color: var(--claude-text);
  line-height: 1.6;
  margin: 0;
  padding: 0;
}

h1, h2, h3 {
  font-family: 'Source Serif 4', Georgia, serif;
  font-weight: 400;
  letter-spacing: -0.02em;
  line-height: 1.2;
}

code, pre, .font-mono {
  font-family: 'JetBrains Mono', 'SF Mono', monospace;
  font-size: 0.9em;
}

::selection {
  background: var(--claude-terracotta-subtle);
}

:focus-visible {
  outline: none;
  box-shadow: var(--shadow-glow);
}

::-webkit-scrollbar { width: 10px; height: 10px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb {
  background: var(--claude-border-strong);
  border-radius: 100px;
  border: 3px solid var(--claude-bg);
}
::-webkit-scrollbar-thumb:hover { background: var(--claude-text-muted); }

@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
@keyframes fadeInUp { from { opacity: 0; transform: translateY(16px); } to { opacity: 1; transform: translateY(0); } }
@keyframes slideInRight { from { opacity: 0; transform: translateX(24px); } to { opacity: 1; transform: translateX(0); } }
@keyframes slideInLeft { from { opacity: 0; transform: translateX(-24px); } to { opacity: 1; transform: translateX(0); } }
@keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
@keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

.animate-fade-in { animation: fadeIn 0.5s var(--ease-out-expo) forwards; }
.animate-fade-in-up { animation: fadeInUp 0.6s var(--ease-out-expo) forwards; }
.animate-slide-in-right { animation: slideInRight 0.5s var(--ease-out-expo) forwards; }
.animate-slide-in-left { animation: slideInLeft 0.5s var(--ease-out-expo) forwards; }
.animate-spin { animation: spin 1s linear infinite; }
.animate-pulse { animation: pulse 2s ease-in-out infinite; }

.claude-spinner {
  width: 24px;
  height: 24px;
  border: 2px solid var(--claude-terracotta-subtle);
  border-top-color: var(--claude-terracotta);
  border-radius: 50%;
  animation: spin 1s ease-in-out infinite;
}

.prose { color: var(--claude-text); line-height: 1.7; font-size: 15px; }
.prose p { margin-bottom: 1em; }
.prose p:last-child { margin-bottom: 0; }
.prose code {
  background: var(--claude-sand-light);
  padding: 3px 7px;
  border-radius: 6px;
  font-size: 0.875em;
  color: var(--claude-terracotta);
}
.prose pre {
  background: var(--claude-surface-sunken);
  border: 1px solid var(--claude-border);
  border-radius: 14px;
  padding: 18px;
  overflow-x: auto;
  margin: 18px 0;
}
.prose pre code {
  background: transparent;
  padding: 0;
  color: var(--claude-text);
}
.prose a { color: var(--claude-terracotta); text-decoration: underline; }
.prose ul, .prose ol { padding-left: 1.5em; margin: 1em 0; }
.prose li { margin: 0.5em 0; }
.prose blockquote {
  border-left: 3px solid var(--claude-terracotta);
  padding-left: 1.25em;
  margin: 1.25em 0;
  color: var(--claude-text-secondary);
  font-style: italic;
}
.prose strong { font-weight: 600; }

.glass {
  background: rgba(255, 255, 255, 0.8);
  backdrop-filter: blur(20px);
  border: 1px solid rgba(255, 255, 255, 0.4);
}
.dark .glass {
  background: rgba(42, 41, 40, 0.85);
  border: 1px solid rgba(255, 255, 255, 0.08);
}

.badge {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 6px 12px;
  background: var(--claude-sand-light);
  border-radius: 100px;
  font-size: 13px;
  font-weight: 500;
  color: var(--claude-text-secondary);
}
.badge-success { background: rgba(74, 157, 110, 0.12); color: var(--claude-success); }
.badge-warning { background: rgba(212, 168, 67, 0.12); color: var(--claude-warning); }
.badge-error { background: rgba(199, 93, 93, 0.12); color: var(--claude-error); }

.stagger > * { opacity: 0; animation: fadeInUp 0.5s var(--ease-out-expo) forwards; }
.stagger > *:nth-child(1) { animation-delay: 0s; }
.stagger > *:nth-child(2) { animation-delay: 0.06s; }
.stagger > *:nth-child(3) { animation-delay: 0.12s; }
.stagger > *:nth-child(4) { animation-delay: 0.18s; }
.stagger > *:nth-child(5) { animation-delay: 0.24s; }
.stagger > *:nth-child(6) { animation-delay: 0.30s; }



==================================================
FILE: ./src/app/layout.tsx
==================================================
import type { Metadata } from 'next';
import './globals.css';

export const metadata: Metadata = {
  title: 'Claude Coder',
  description: 'AI-powered coding assistant with GitHub integration',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body className="min-h-screen">
        {children}
      </body>
    </html>
  );
}



==================================================
FILE: ./src/app/page.tsx
==================================================
'use client';

import React, { useState, useEffect, useRef } from 'react';
import {
  Send,
  Settings as SettingsIcon,
  Plus,
  GitBranch,
  ChevronDown,
  Moon,
  Sun,
  Square,
  Search,
  Brain,
  Lock
} from 'lucide-react';
import {
  Message,
  Conversation,
  Settings,
  Repository,
  UploadedFile,
  Artifact,
  FileChange,
  DEFAULT_SETTINGS,
  ModelType,
  MODEL_DISPLAY_NAMES,
  WebSearchMode,
} from '@/types';

// Component imports
import Sidebar from '@/components/Sidebar';
import ChatMessage from '@/components/ChatMessage';
import WelcomeScreen from '@/components/WelcomeScreen';
import SettingsPanel from '@/components/SettingsPanel';
import ArtifactPanel from '@/components/ArtifactPanel';
import ArtifactsList from '@/components/ArtifactsList';
import FileUpload from '@/components/FileUpload';
import LoadingSpinner from '@/components/LoadingSpinner';
import CostTracker from '@/components/CostTracker';
import QuickSettings from '@/components/QuickSettings';

// ============================================================================
// MAIN PAGE COMPONENT
// ============================================================================

export default function Home() {
  // --------------------------------------------------------------------------
  // STATE - Auth
  // --------------------------------------------------------------------------
  const [isUnlocked, setIsUnlocked] = useState<boolean>(false);
  const [password, setPassword] = useState<string>('');
  const [loginError, setLoginError] = useState<string>('');
  const [rememberMe, setRememberMe] = useState<boolean>(false);

  // --------------------------------------------------------------------------
  // STATE - API Keys
  // --------------------------------------------------------------------------
  const [anthropicKey, setAnthropicKey] = useState<string>('');
  const [githubToken, setGithubToken] = useState<string>('');
  const [isAuthenticated, setIsAuthenticated] = useState<boolean>(false);
  const [githubUser, setGithubUser] = useState<string>('');

  // --------------------------------------------------------------------------
  // STATE - Repository
  // --------------------------------------------------------------------------
  const [repos, setRepos] = useState<Repository[]>([]);
  const [currentRepo, setCurrentRepo] = useState<Repository | null>(null);
  const [currentBranch, setCurrentBranch] = useState<string>('main');
  const [branches, setBranches] = useState<string[]>(['main']);

  // --------------------------------------------------------------------------
  // STATE - Conversations & Messages
  // --------------------------------------------------------------------------
  const [conversations, setConversations] = useState<Conversation[]>([]);
  const [currentConversationId, setCurrentConversationId] = useState<string | null>(null);
  const [messages, setMessages] = useState<Message[]>([]);
  const [inputValue, setInputValue] = useState<string>('');
  const [uploadedFiles, setUploadedFiles] = useState<UploadedFile[]>([]);

  // --------------------------------------------------------------------------
  // STATE - UI
  // --------------------------------------------------------------------------
  const [sidebarOpen, setSidebarOpen] = useState<boolean>(true);
  const [settingsOpen, setSettingsOpen] = useState<boolean>(false);
  const [quickSettingsOpen, setQuickSettingsOpen] = useState<boolean>(false);
  const [darkMode, setDarkMode] = useState<boolean>(false);
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [isStreaming, setIsStreaming] = useState<boolean>(false);
  const [showRepoDropdown, setShowRepoDropdown] = useState<boolean>(false);
  const [showModelDropdown, setShowModelDropdown] = useState<boolean>(false);

  // --------------------------------------------------------------------------
  // STATE - Settings
  // --------------------------------------------------------------------------
  const [settings, setSettings] = useState<Settings>(DEFAULT_SETTINGS);

  // --------------------------------------------------------------------------
  // STATE - Artifacts
  // --------------------------------------------------------------------------
  const [artifacts, setArtifacts] = useState<Artifact[]>([]);
  const [selectedArtifact, setSelectedArtifact] = useState<Artifact | null>(null);
  const [showArtifactsList, setShowArtifactsList] = useState<boolean>(false);

  // --------------------------------------------------------------------------
  // STATE - Cost Tracking
  // --------------------------------------------------------------------------
  const [sessionCost, setSessionCost] = useState<number>(0);
  const [totalCost, setTotalCost] = useState<number>(0);

  // --------------------------------------------------------------------------
  // REFS
  // --------------------------------------------------------------------------
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLTextAreaElement>(null);
  const abortControllerRef = useRef<AbortController | null>(null);

  // --------------------------------------------------------------------------
  // EFFECTS - Initialize from localStorage
  // --------------------------------------------------------------------------
  useEffect(() => {
    // Check if already unlocked (remembered)
    const savedUnlocked = localStorage.getItem('isUnlocked');
    if (savedUnlocked === 'true') {
      setIsUnlocked(true);
    }

    // Load saved state
    const savedAnthropicKey = localStorage.getItem('anthropicKey');
    const savedGithubToken = localStorage.getItem('githubToken');
    const savedRepo = localStorage.getItem('currentRepo');
    const savedBranch = localStorage.getItem('currentBranch');
    const savedConversations = localStorage.getItem('conversations');
    const savedSettings = localStorage.getItem('settings');
    const savedDarkMode = localStorage.getItem('darkMode');
    const savedCurrentConvId = localStorage.getItem('currentConversationId');
    const savedTotalCost = localStorage.getItem('totalCost');

    if (savedAnthropicKey) setAnthropicKey(savedAnthropicKey);
    if (savedGithubToken) setGithubToken(savedGithubToken);
    if (savedRepo) setCurrentRepo(JSON.parse(savedRepo));
    if (savedBranch) setCurrentBranch(savedBranch);
    if (savedConversations) setConversations(JSON.parse(savedConversations));
    if (savedSettings) {
      const parsed = JSON.parse(savedSettings);
      // Ensure webSearchMode exists for migrating old settings
      if (!parsed.webSearchMode) {
        parsed.webSearchMode = parsed.enableWebSearch ? 'auto' : 'off';
      }
      setSettings(parsed);
    }
    if (savedDarkMode) setDarkMode(savedDarkMode === 'true');
    if (savedCurrentConvId) setCurrentConversationId(savedCurrentConvId);
    if (savedTotalCost) setTotalCost(parseFloat(savedTotalCost));

    // Check if API key is valid
    if (savedAnthropicKey) {
      setIsAuthenticated(true);
      // Only fetch repos if we have a GitHub token
      if (savedGithubToken) {
        fetchRepos(savedGithubToken);
      }
    }
  }, []);

  // --------------------------------------------------------------------------
  // EFFECTS - Save to localStorage
  // --------------------------------------------------------------------------
  useEffect(() => {
    if (anthropicKey) localStorage.setItem('anthropicKey', anthropicKey);
    if (githubToken) localStorage.setItem('githubToken', githubToken);
    if (currentRepo) localStorage.setItem('currentRepo', JSON.stringify(currentRepo));
    if (currentBranch) localStorage.setItem('currentBranch', currentBranch);
    if (conversations.length > 0) localStorage.setItem('conversations', JSON.stringify(conversations));
    localStorage.setItem('settings', JSON.stringify(settings));
    localStorage.setItem('darkMode', String(darkMode));
    if (currentConversationId) localStorage.setItem('currentConversationId', currentConversationId);
    localStorage.setItem('totalCost', String(totalCost));
  }, [anthropicKey, githubToken, currentRepo, currentBranch, conversations, settings, darkMode, currentConversationId, totalCost]);

  // --------------------------------------------------------------------------
  // EFFECTS - Dark mode class
  // --------------------------------------------------------------------------
  useEffect(() => {
    if (darkMode) {
      document.documentElement.classList.add('dark');
    } else {
      document.documentElement.classList.remove('dark');
    }
  }, [darkMode]);

  // --------------------------------------------------------------------------
  // EFFECTS - Scroll to bottom on new messages
  // --------------------------------------------------------------------------
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  // --------------------------------------------------------------------------
  // EFFECTS - Load messages when conversation changes
  // --------------------------------------------------------------------------
  useEffect(() => {
    if (currentConversationId) {
      const conv = conversations.find(c => c.id === currentConversationId);
      if (conv) {
        setMessages(conv.messages);
        setArtifacts(conv.messages.flatMap(m => m.artifacts || []));
      }
    } else {
      setMessages([]);
      setArtifacts([]);
    }
  }, [currentConversationId, conversations]);

  // --------------------------------------------------------------------------
  // FUNCTIONS - Login with password
  // --------------------------------------------------------------------------
  const handleLogin = async () => {
    setIsLoading(true);
    setLoginError('');

    try {
      const response = await fetch('/api/auth', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ action: 'login', password }),
      });
      const data = await response.json();

      if (data.success) {
        setIsUnlocked(true);
        if (rememberMe) {
          localStorage.setItem('isUnlocked', 'true');
        }
      } else {
        setLoginError(data.error || 'Invalid password');
      }
    } catch {
      setLoginError('Connection error');
    } finally {
      setIsLoading(false);
    }
  };

  // --------------------------------------------------------------------------
  // FUNCTIONS - Fetch repos
  // --------------------------------------------------------------------------
  const fetchRepos = async (token: string) => {
    try {
      const response = await fetch('/api/auth', {
        headers: { 'x-github-token': token },
      });
      const data = await response.json();
      if (data.repos) {
        setRepos(data.repos);
      }
    } catch (error) {
      console.error('Failed to fetch repos:', error);
    }
  };

  // --------------------------------------------------------------------------
  // FUNCTIONS - Authenticate API keys
  // --------------------------------------------------------------------------
  const handleAuthenticate = async () => {
    if (!anthropicKey) return;

    setIsLoading(true);
    try {
      const response = await fetch('/api/auth', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'validate',
          anthropicKey,
          githubToken: githubToken || undefined
        }),
      });
      const data = await response.json();

      if (data.anthropic?.valid) {
        setIsAuthenticated(true);
        if (data.github?.valid) {
          setGithubUser(data.github.user);
          await fetchRepos(githubToken);
        }
      } else {
        alert('Invalid Anthropic API key. Please check your credentials.');
      }
    } catch (error) {
      console.error('Auth error:', error);
      alert('Authentication failed');
    } finally {
      setIsLoading(false);
    }
  };

  // --------------------------------------------------------------------------
  // FUNCTIONS - Select repo (LAZY - NO API CALLS)
  // --------------------------------------------------------------------------
  const handleSelectRepo = (repo: Repository | null) => {
    setCurrentRepo(repo);
    if (repo) {
      setCurrentBranch(repo.defaultBranch);
      // LAZY LOADING: Don't fetch branches here
      // Branches will be fetched on first message if needed
      setBranches([repo.defaultBranch]);
    } else {
      setCurrentBranch('main');
      setBranches(['main']);
    }
    setShowRepoDropdown(false);
  };

  // --------------------------------------------------------------------------
  // FUNCTIONS - New chat
  // --------------------------------------------------------------------------
  const handleNewChat = () => {
    const newConv: Conversation = {
      id: `conv-${Date.now()}`,
      title: 'New conversation',
      messages: [],
      createdAt: new Date(),
      updatedAt: new Date(),
      repoOwner: currentRepo?.owner,
      repoName: currentRepo?.name,
      branch: currentBranch,
    };
    setConversations(prev => [newConv, ...prev]);
    setCurrentConversationId(newConv.id);
    setMessages([]);
    setArtifacts([]);
    setSessionCost(0);
    setUploadedFiles([]);
  };

  // --------------------------------------------------------------------------
  // FUNCTIONS - Stop streaming
  // --------------------------------------------------------------------------
  const handleStop = () => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
      abortControllerRef.current = null;
      setIsStreaming(false);
    }
  };

  // --------------------------------------------------------------------------
  // FUNCTIONS - Send message
  // --------------------------------------------------------------------------
  const handleSendMessage = async () => {
    if (!inputValue.trim() || isStreaming) return;

    // Create or get conversation
    let convId = currentConversationId;
    if (!convId) {
      const newConv: Conversation = {
        id: `conv-${Date.now()}`,
        title: inputValue.slice(0, 50),
        messages: [],
        createdAt: new Date(),
        updatedAt: new Date(),
        repoOwner: currentRepo?.owner,
        repoName: currentRepo?.name,
        branch: currentBranch,
      };
      setConversations(prev => [newConv, ...prev]);
      convId = newConv.id;
      setCurrentConversationId(convId);
    }

    // Create user message
    const userMessage: Message = {
      id: `msg-${Date.now()}`,
      role: 'user',
      content: inputValue,
      timestamp: new Date(),
      files: uploadedFiles.length > 0 ? [...uploadedFiles] : undefined,
    };

    // Create placeholder assistant message
    const assistantMessage: Message = {
      id: `msg-${Date.now() + 1}`,
      role: 'assistant',
      content: '',
      timestamp: new Date(),
      isStreaming: true,
    };

    // Update UI
    const newMessages = [...messages, userMessage, assistantMessage];
    setMessages(newMessages);
    setInputValue('');
    setUploadedFiles([]);
    setIsStreaming(true);

    // Create abort controller for stop button
    abortControllerRef.current = new AbortController();

    try {
      // Prepare API request - repo context is optional
      const apiMessages = newMessages
        .filter(m => !m.isStreaming)
        .map(m => ({ role: m.role, content: m.content }));

      // Build headers
      const headers: Record<string, string> = {
        'Content-Type': 'application/json',
        'x-anthropic-key': anthropicKey,
      };
      if (githubToken) {
        headers['x-github-token'] = githubToken;
      }

      // Determine if web search should be enabled based on mode
      const webSearchEnabled = settings.webSearchMode !== 'off';
      const effectiveSettings = {
        ...settings,
        enableWebSearch: webSearchEnabled,
      };

      // Use PUT for streaming
      const response = await fetch('/api/chat', {
        method: 'PUT',
        headers,
        body: JSON.stringify({
          messages: apiMessages,
          settings: effectiveSettings,
          repoContext: currentRepo ? {
            owner: currentRepo.owner,
            repo: currentRepo.name,
            branch: currentBranch,
          } : { owner: '', repo: '', branch: '' },
          files: userMessage.files,
        }),
        signal: abortControllerRef.current.signal,
      });

      if (!response.ok) {
        throw new Error('API request failed');
      }

      // Process stream
      const reader = response.body?.getReader();
      if (!reader) throw new Error('No response body');

      const decoder = new TextDecoder();
      let accumulatedContent = '';
      let accumulatedThinking = '';
      let finalCost = 0;
      let finalSavedPercent = 0;
      const allArtifacts: Artifact[] = [];
      const allFileChanges: FileChange[] = [];

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        const text = decoder.decode(value, { stream: true });
        const lines = text.split('\n').filter(line => line.trim());

        for (const line of lines) {
          try {
            const chunk = JSON.parse(line);

            if (chunk.type === 'text') {
              accumulatedContent += chunk.content || '';
              setMessages(prev => prev.map(m =>
                m.id === assistantMessage.id
                  ? { ...m, content: accumulatedContent }
                  : m
              ));
            } else if (chunk.type === 'thinking') {
              accumulatedThinking += chunk.content || '';
              setMessages(prev => prev.map(m =>
                m.id === assistantMessage.id
                  ? { ...m, thinkingContent: accumulatedThinking }
                  : m
              ));
            } else if (chunk.type === 'tool_use') {
              if (chunk.toolCall?.name === 'str_replace' || chunk.toolCall?.name === 'create_file') {
                const input = chunk.toolCall.input;
                allFileChanges.push({
                  path: input.path,
                  action: chunk.toolCall.name === 'create_file' ? 'create' : 'edit',
                });
              }
            } else if (chunk.type === 'done') {
              finalCost = chunk.cost || 0;
              finalSavedPercent = chunk.savedPercent || 0;
              if (chunk.fileChanges) {
                allFileChanges.push(...chunk.fileChanges);
              }
            } else if (chunk.error) {
              throw new Error(chunk.error);
            }
          } catch (e) {
            if (!(e instanceof SyntaxError)) throw e;
          }
        }
      }

      // Parse artifacts from content
      const artifactRegex = /```(\w+)?\n([\s\S]*?)```/g;
      let match;
      let idx = 0;
      while ((match = artifactRegex.exec(accumulatedContent)) !== null) {
        const language = match[1]?.toLowerCase() || 'text';
        allArtifacts.push({
          id: `artifact-${idx++}`,
          name: `Code ${idx}`,
          type: language === 'html' ? 'html' : language === 'svg' ? 'svg' : 'code',
          content: match[2],
          language,
        });
      }

      // Final update
      const updatedAssistant: Message = {
        ...assistantMessage,
        content: accumulatedContent,
        isStreaming: false,
        cost: finalCost,
        savedPercent: finalSavedPercent,
        thinkingContent: accumulatedThinking || undefined,
        artifacts: allArtifacts.length > 0 ? allArtifacts : undefined,
        filesChanged: allFileChanges.length > 0 ? allFileChanges : undefined,
      };

      const finalMessages = [...messages, userMessage, updatedAssistant];
      setMessages(finalMessages);

      if (allArtifacts.length > 0) {
        setArtifacts(prev => [...prev, ...allArtifacts]);
      }

      setSessionCost(prev => prev + finalCost);
      setTotalCost(prev => prev + finalCost);

      setConversations(prev => prev.map(c =>
        c.id === convId
          ? {
              ...c,
              title: c.messages.length === 0 ? inputValue.slice(0, 50) : c.title,
              messages: finalMessages,
              updatedAt: new Date(),
              totalCost: (c.totalCost || 0) + finalCost,
              filesChanged: allFileChanges.length > 0 ? [...(c.filesChanged || []), ...allFileChanges] : c.filesChanged,
            }
          : c
      ));

    } catch (error) {
      if ((error as Error).name === 'AbortError') {
        // User cancelled - update message to show partial content
        setMessages(prev => prev.map(m =>
          m.id === assistantMessage.id
            ? { ...m, isStreaming: false, content: m.content || '(Cancelled)' }
            : m
        ));
      } else {
        console.error('Chat error:', error);
        const errorMessage: Message = {
          ...assistantMessage,
          content: 'Sorry, an error occurred. Please try again.',
          isStreaming: false,
        };
        setMessages([...messages, userMessage, errorMessage]);
      }
    } finally {
      setIsStreaming(false);
      abortControllerRef.current = null;
    }
  };

  // --------------------------------------------------------------------------
  // FUNCTIONS - Handle key press
  // --------------------------------------------------------------------------
  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  };

  // --------------------------------------------------------------------------
  // FUNCTIONS - Cycle web search mode
  // --------------------------------------------------------------------------
  const cycleWebSearchMode = () => {
    const modes: WebSearchMode[] = ['off', 'manual', 'auto'];
    const currentIndex = modes.indexOf(settings.webSearchMode);
    const nextIndex = (currentIndex + 1) % modes.length;
    setSettings(prev => ({
      ...prev,
      webSearchMode: modes[nextIndex],
      enableWebSearch: modes[nextIndex] !== 'off',
    }));
  };

  // --------------------------------------------------------------------------
  // FUNCTIONS - Toggle extended thinking
  // --------------------------------------------------------------------------
  const toggleExtendedThinking = () => {
    setSettings(prev => ({
      ...prev,
      enableExtendedThinking: !prev.enableExtendedThinking,
    }));
  };

  // --------------------------------------------------------------------------
  // FUNCTIONS - View PR
  // --------------------------------------------------------------------------
  const handleViewPR = (prUrl?: string) => {
    if (prUrl) {
      window.open(prUrl, '_blank');
    }
  };

  // --------------------------------------------------------------------------
  // FUNCTIONS - Discard changes
  // --------------------------------------------------------------------------
  const handleDiscard = async (branch?: string) => {
    if (!branch || !currentRepo) return;

    try {
      await fetch('/api/github', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-github-token': githubToken,
        },
        body: JSON.stringify({
          action: 'deleteBranch',
          owner: currentRepo.owner,
          repo: currentRepo.name,
          branch,
        }),
      });
    } catch (error) {
      console.error('Failed to discard:', error);
    }
  };

  // --------------------------------------------------------------------------
  // FUNCTIONS - Download all artifacts
  // --------------------------------------------------------------------------
  const handleDownloadAllArtifacts = () => {
    artifacts.forEach(artifact => {
      const ext = artifact.language || artifact.type;
      const blob = new Blob([artifact.content], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${artifact.name || 'artifact'}.${ext}`;
      a.click();
      URL.revokeObjectURL(url);
    });
  };

  // --------------------------------------------------------------------------
  // FUNCTIONS - Logout
  // --------------------------------------------------------------------------
  const handleLogout = () => {
    setIsUnlocked(false);
    localStorage.removeItem('isUnlocked');
  };

  // --------------------------------------------------------------------------
  // RENDER - Login Screen
  // --------------------------------------------------------------------------
  if (!isUnlocked) {
    return (
      <div className="min-h-screen flex items-center justify-center p-8 bg-[var(--claude-bg)]">
        <div className="w-full max-w-sm space-y-6 animate-fade-in-up">
          <div className="text-center mb-8">
            <div className="w-16 h-16 mx-auto mb-4 rounded-2xl bg-[var(--claude-terracotta-subtle)] flex items-center justify-center">
              <Lock className="w-8 h-8 text-[var(--claude-terracotta)]" />
            </div>
            <h1 className="text-2xl font-serif text-[var(--claude-text)]">Claude Coder</h1>
            <p className="text-[var(--claude-text-secondary)] mt-1">Enter password to continue</p>
          </div>

          <div className="space-y-4">
            <input
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              onKeyDown={(e) => e.key === 'Enter' && handleLogin()}
              placeholder="Password"
              className="w-full px-4 py-3 rounded-xl bg-[var(--claude-surface)] border border-[var(--claude-border)] text-[var(--claude-text)] placeholder:text-[var(--claude-text-muted)] focus:outline-none focus:border-[var(--claude-terracotta)]"
              autoFocus
            />

            {loginError && (
              <p className="text-sm text-[var(--claude-error)]">{loginError}</p>
            )}

            <label className="flex items-center gap-2 cursor-pointer">
              <input
                type="checkbox"
                checked={rememberMe}
                onChange={(e) => setRememberMe(e.target.checked)}
                className="w-4 h-4 rounded border-[var(--claude-border)] text-[var(--claude-terracotta)] focus:ring-[var(--claude-terracotta)]"
              />
              <span className="text-sm text-[var(--claude-text-secondary)]">Remember me</span>
            </label>

            <button
              onClick={handleLogin}
              disabled={!password || isLoading}
              className="w-full px-4 py-3 rounded-xl bg-[var(--claude-terracotta)] text-white font-medium hover:bg-[var(--claude-terracotta-hover)] disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center justify-center gap-2"
            >
              {isLoading ? <LoadingSpinner size="sm" /> : null}
              {isLoading ? 'Unlocking...' : 'Unlock'}
            </button>
          </div>
        </div>
      </div>
    );
  }

  // --------------------------------------------------------------------------
  // RENDER - Setup Screen (No API Key)
  // --------------------------------------------------------------------------
  if (!isAuthenticated) {
    return (
      <div className="min-h-screen flex items-center justify-center p-8 bg-[var(--claude-bg)]">
        <div className="w-full max-w-md space-y-6 animate-fade-in-up">
          <div className="text-center mb-8">
            <h1 className="text-3xl font-serif text-[var(--claude-text)] mb-2">Claude Coder</h1>
            <p className="text-[var(--claude-text-secondary)]">Setup required - add your API keys</p>
          </div>

          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-[var(--claude-text-secondary)] mb-2">
                Anthropic API Key <span className="text-[var(--claude-error)]">*</span>
              </label>
              <input
                type="password"
                value={anthropicKey}
                onChange={(e) => setAnthropicKey(e.target.value)}
                placeholder="sk-ant-..."
                className="w-full px-4 py-3 rounded-xl bg-[var(--claude-surface)] border border-[var(--claude-border)] text-[var(--claude-text)] placeholder:text-[var(--claude-text-muted)] focus:outline-none focus:border-[var(--claude-terracotta)]"
              />
              <a
                href="https://console.anthropic.com/settings/keys"
                target="_blank"
                rel="noopener noreferrer"
                className="text-xs text-[var(--claude-terracotta)] hover:underline mt-1 inline-block"
              >
                Get API key 
              </a>
            </div>

            <div>
              <label className="block text-sm font-medium text-[var(--claude-text-secondary)] mb-2">
                GitHub Token <span className="text-[var(--claude-text-muted)]">(optional)</span>
              </label>
              <input
                type="password"
                value={githubToken}
                onChange={(e) => setGithubToken(e.target.value)}
                placeholder="ghp_... (needed for code editing)"
                className="w-full px-4 py-3 rounded-xl bg-[var(--claude-surface)] border border-[var(--claude-border)] text-[var(--claude-text)] placeholder:text-[var(--claude-text-muted)] focus:outline-none focus:border-[var(--claude-terracotta)]"
              />
              <a
                href="https://github.com/settings/tokens"
                target="_blank"
                rel="noopener noreferrer"
                className="text-xs text-[var(--claude-terracotta)] hover:underline mt-1 inline-block"
              >
                Get token 
              </a>
            </div>

            <button
              onClick={handleAuthenticate}
              disabled={!anthropicKey || isLoading}
              className="w-full px-4 py-3 rounded-xl bg-[var(--claude-terracotta)] text-white font-medium hover:bg-[var(--claude-terracotta-hover)] disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center justify-center gap-2"
            >
              {isLoading ? <LoadingSpinner size="sm" /> : null}
              {isLoading ? 'Connecting...' : 'Connect'}
            </button>
          </div>
        </div>
      </div>
    );
  }

  // --------------------------------------------------------------------------
  // RENDER - Main App
  // --------------------------------------------------------------------------
  const currentModel = MODEL_DISPLAY_NAMES[settings.model] || MODEL_DISPLAY_NAMES['claude-sonnet-4-5-20250929'];

  return (
    <div className={`min-h-screen flex ${darkMode ? 'dark' : ''}`}>
      {/* Sidebar */}
      <Sidebar
        isOpen={sidebarOpen}
        onToggle={() => setSidebarOpen(!sidebarOpen)}
        conversations={conversations}
        currentConversationId={currentConversationId}
        onNewChat={handleNewChat}
        onSelectConversation={setCurrentConversationId}
        totalCost={totalCost}
      />

      {/* Main Content */}
      <div className="flex-1 flex flex-col min-w-0 bg-[var(--claude-bg)]">
        {/* Header */}
        <header className="flex-shrink-0 flex items-center justify-between px-4 py-3 border-b border-[var(--claude-border)] bg-[var(--claude-surface)]">
          <div className="flex items-center gap-4">
            <h1 className="text-lg font-serif text-[var(--claude-text)]">Claude Coder</h1>

            {/* Repo selector */}
            <div className="relative">
              <button
                onClick={() => setShowRepoDropdown(!showRepoDropdown)}
                className="flex items-center gap-2 px-3 py-1.5 rounded-lg bg-[var(--claude-surface-sunken)] border border-[var(--claude-border)] text-sm text-[var(--claude-text)] hover:border-[var(--claude-border-strong)] transition-colors"
              >
                <GitBranch className="w-4 h-4 text-[var(--claude-text-muted)]" />
                {currentRepo ? currentRepo.fullName : 'No Repo'}
                <ChevronDown className="w-3 h-3 text-[var(--claude-text-muted)]" />
              </button>

              {showRepoDropdown && (
                <div className="absolute top-full left-0 mt-1 w-72 max-h-80 overflow-y-auto rounded-xl bg-[var(--claude-surface)] border border-[var(--claude-border)] shadow-lg z-20">
                  {/* No Repo option */}
                  <button
                    onClick={() => handleSelectRepo(null)}
                    className={`w-full px-4 py-2 text-left text-sm hover:bg-[var(--claude-sand-light)] transition-colors ${
                      !currentRepo ? 'bg-[var(--claude-terracotta-subtle)]' : ''
                    }`}
                  >
                    <p className="font-medium text-[var(--claude-text)]">No Repo</p>
                    <p className="text-xs text-[var(--claude-text-muted)]">Just chat with Claude</p>
                  </button>
                  <div className="border-t border-[var(--claude-border)]" />
                  {repos.map((repo) => (
                    <button
                      key={repo.fullName}
                      onClick={() => handleSelectRepo(repo)}
                      className={`w-full px-4 py-2 text-left text-sm hover:bg-[var(--claude-sand-light)] transition-colors ${
                        currentRepo?.fullName === repo.fullName ? 'bg-[var(--claude-terracotta-subtle)]' : ''
                      }`}
                    >
                      <p className="font-medium text-[var(--claude-text)]">{repo.fullName}</p>
                      <p className="text-xs text-[var(--claude-text-muted)]">{repo.defaultBranch}</p>
                    </button>
                  ))}
                  {repos.length === 0 && githubToken && (
                    <p className="px-4 py-2 text-sm text-[var(--claude-text-muted)]">Loading repos...</p>
                  )}
                  {!githubToken && (
                    <p className="px-4 py-2 text-sm text-[var(--claude-text-muted)]">
                      Add GitHub token in settings to connect repos
                    </p>
                  )}
                </div>
              )}
            </div>

            {/* Branch selector (only if repo selected) */}
            {currentRepo && (
              <select
                value={currentBranch}
                onChange={(e) => setCurrentBranch(e.target.value)}
                className="px-3 py-1.5 rounded-lg bg-[var(--claude-surface-sunken)] border border-[var(--claude-border)] text-sm text-[var(--claude-text)] focus:outline-none"
              >
                {branches.map((branch) => (
                  <option key={branch} value={branch}>{branch}</option>
                ))}
              </select>
            )}

            {/* Mode badge */}
            {currentRepo && (
              <span className={`badge ${settings.deployMode === 'safe' ? 'badge-success' : 'badge-warning'}`}>
                {settings.deployMode === 'safe' ? ' Safe' : ' Direct'}
              </span>
            )}
          </div>

          <div className="flex items-center gap-3">
            {/* Cost display */}
            <CostTracker
              cost={sessionCost}
              sessionTotal={totalCost}
              compact
            />

            {/* Dark mode toggle */}
            <button
              onClick={() => setDarkMode(!darkMode)}
              className="p-2 rounded-lg hover:bg-[var(--claude-sand-light)] text-[var(--claude-text-secondary)] transition-colors"
            >
              {darkMode ? <Sun className="w-5 h-5" /> : <Moon className="w-5 h-5" />}
            </button>

            {/* Settings button */}
            <button
              onClick={() => setSettingsOpen(true)}
              className="p-2 rounded-lg hover:bg-[var(--claude-sand-light)] text-[var(--claude-text-secondary)] transition-colors"
            >
              <SettingsIcon className="w-5 h-5" />
            </button>
          </div>
        </header>

        {/* Messages area */}
        <div className="flex-1 overflow-y-auto">
          {messages.length === 0 ? (
            <WelcomeScreen repo={currentRepo} branch={currentBranch} />
          ) : (
            <div className="pb-32">
              {messages.map((message) => (
              <ChatMessage
                key={message.id}
                message={message}
                onViewPR={() => {
                  const prUrl = currentRepo
                    ? `https://github.com/${currentRepo.owner}/${currentRepo.name}/pulls`
                    : undefined;
                  handleViewPR(prUrl);
                }}
                onDiscard={() => handleDiscard()}
              />
              ))}
              <div ref={messagesEndRef} />
            </div>
          )}
        </div>

        {/* Input area */}
        <div className="flex-shrink-0 border-t border-[var(--claude-border)] bg-[var(--claude-surface)] p-4">
          <div className="max-w-3xl mx-auto">
            {/* File upload */}
            {uploadedFiles.length > 0 && (
              <div className="mb-3">
                <FileUpload
                  files={uploadedFiles}
                  onFilesChange={setUploadedFiles}
                />
              </div>
            )}

            {/* Input row */}
            <div className="flex items-end gap-2">
              {/* Attach button */}
              <button
                onClick={() => document.getElementById('file-input')?.click()}
                className="p-3 rounded-xl hover:bg-[var(--claude-sand-light)] text-[var(--claude-text-secondary)] transition-colors"
                title="Attach files"
              >
                <Plus className="w-5 h-5" />
              </button>
              <input
                id="file-input"
                type="file"
                multiple
                className="hidden"
                onChange={(e) => {
                  if (e.target.files) {
                    const newFiles = Array.from(e.target.files);
                    Promise.all(newFiles.map(async (file) => {
                      const base64 = await new Promise<string>((resolve) => {
                        const reader = new FileReader();
                        reader.onload = () => resolve((reader.result as string).split(',')[1]);
                        reader.readAsDataURL(file);
                      });
                      return {
                        name: file.name,
                        type: file.type,
                        size: file.size,
                        base64,
                      };
                    })).then(files => setUploadedFiles(prev => [...prev, ...files]));
                  }
                }}
              />

              {/* Quick settings */}
              <div className="relative">
                <button
                  onClick={() => setQuickSettingsOpen(!quickSettingsOpen)}
                  className="p-3 rounded-xl hover:bg-[var(--claude-sand-light)] text-[var(--claude-text-secondary)] transition-colors"
                  title="Quick settings"
                >
                  <SettingsIcon className="w-5 h-5" />
                </button>
                <QuickSettings
                  isOpen={quickSettingsOpen}
                  onClose={() => setQuickSettingsOpen(false)}
                  settings={settings}
                  onSettingsChange={setSettings}
                  onOpenFullSettings={() => {
                    setQuickSettingsOpen(false);
                    setSettingsOpen(true);
                  }}
                />
              </div>

              {/* Input */}
              <textarea
                ref={inputRef}
                value={inputValue}
                onChange={(e) => setInputValue(e.target.value)}
                onKeyDown={handleKeyPress}
                placeholder="Ask Claude anything..."
                disabled={isStreaming}
                rows={1}
                className="flex-1 px-4 py-3 rounded-xl bg-[var(--claude-surface-sunken)] border border-[var(--claude-border)] text-[var(--claude-text)] placeholder:text-[var(--claude-text-muted)] focus:outline-none focus:border-[var(--claude-terracotta)] resize-none disabled:opacity-50"
                style={{ minHeight: '48px', maxHeight: '200px' }}
              />

              {/* Model dropdown */}
              <div className="relative">
                <button
                  onClick={() => setShowModelDropdown(!showModelDropdown)}
                  className="flex items-center gap-1 px-3 py-3 rounded-xl bg-[var(--claude-surface-sunken)] border border-[var(--claude-border)] text-sm text-[var(--claude-text)] hover:border-[var(--claude-border-strong)] transition-colors"
                  title="Select model"
                >
                  <span>{currentModel.name}</span>
                  <span className="text-xs">{currentModel.cost}</span>
                  <ChevronDown className="w-3 h-3 text-[var(--claude-text-muted)]" />
                </button>
                {showModelDropdown && (
                  <div className="absolute bottom-full right-0 mb-2 w-56 rounded-xl bg-[var(--claude-surface)] border border-[var(--claude-border)] shadow-lg z-50">
                    {(Object.entries(MODEL_DISPLAY_NAMES) as [ModelType, typeof MODEL_DISPLAY_NAMES[ModelType]][]).map(([modelId, info]) => (
                      <button
                        key={modelId}
                        onClick={() => {
                          setSettings(prev => ({ ...prev, model: modelId }));
                          setShowModelDropdown(false);
                        }}
                        className={`w-full px-4 py-3 text-left hover:bg-[var(--claude-sand-light)] transition-colors first:rounded-t-xl last:rounded-b-xl ${
                          settings.model === modelId ? 'bg-[var(--claude-terracotta-subtle)]' : ''
                        }`}
                      >
                        <div className="flex items-center justify-between">
                          <span className="font-medium text-[var(--claude-text)]">{info.name}</span>
                          <span className="text-xs">{info.cost}</span>
                        </div>
                        <p className="text-xs text-[var(--claude-text-muted)]">{info.description}</p>
                      </button>
                    ))}
                  </div>
                )}
              </div>

              {/* Web search toggle */}
              <button
                onClick={cycleWebSearchMode}
                className={`p-3 rounded-xl transition-colors ${
                  settings.webSearchMode !== 'off'
                    ? 'bg-[var(--claude-terracotta-subtle)] text-[var(--claude-terracotta)]'
                    : 'hover:bg-[var(--claude-sand-light)] text-[var(--claude-text-muted)]'
                }`}
                title={`Web Search: ${settings.webSearchMode}`}
              >
                <div className="relative">
                  <Search className="w-5 h-5" />
                  {settings.webSearchMode === 'auto' && (
                    <span className="absolute -top-1 -right-1 text-[8px] font-bold bg-[var(--claude-terracotta)] text-white rounded px-0.5">
                      A
                    </span>
                  )}
                </div>
              </button>

              {/* Extended thinking toggle */}
              <button
                onClick={toggleExtendedThinking}
                className={`p-3 rounded-xl transition-colors ${
                  settings.enableExtendedThinking
                    ? 'bg-[var(--claude-terracotta-subtle)] text-[var(--claude-terracotta)]'
                    : 'hover:bg-[var(--claude-sand-light)] text-[var(--claude-text-muted)]'
                }`}
                title={`Extended Thinking: ${settings.enableExtendedThinking ? 'ON' : 'OFF'}`}
              >
                <Brain className="w-5 h-5" />
              </button>

              {/* Send/Stop button */}
              {isStreaming ? (
                <button
                  onClick={handleStop}
                  className="p-3 rounded-xl bg-[var(--claude-error)] text-white hover:bg-[var(--claude-error)]/80 transition-colors"
                  title="Stop"
                >
                  <Square className="w-5 h-5" />
                </button>
              ) : (
                <button
                  onClick={handleSendMessage}
                  disabled={!inputValue.trim()}
                  className="p-3 rounded-xl bg-[var(--claude-terracotta)] text-white hover:bg-[var(--claude-terracotta-hover)] disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
                  title="Send"
                >
                  <Send className="w-5 h-5" />
                </button>
              )}
            </div>
          </div>
        </div>
      </div>

      {/* Artifacts Panel */}
      {selectedArtifact && (
        <div className="w-96">
          <ArtifactPanel
            artifact={selectedArtifact}
            onClose={() => setSelectedArtifact(null)}
          />
        </div>
      )}

      {/* Artifacts List */}
      {showArtifactsList && artifacts.length > 0 && (
        <ArtifactsList
          artifacts={artifacts}
          onSelect={setSelectedArtifact}
          onDownloadAll={handleDownloadAllArtifacts}
        />
      )}

      {/* Settings Panel */}
      <SettingsPanel
        isOpen={settingsOpen}
        onClose={() => setSettingsOpen(false)}
        settings={settings}
        onSettingsChange={setSettings}
        darkMode={darkMode}
        onDarkModeChange={setDarkMode}
        anthropicKey={anthropicKey}
        githubToken={githubToken}
        githubUser={githubUser}
        onAnthropicKeyChange={setAnthropicKey}
        onGithubTokenChange={setGithubToken}
        onLogout={handleLogout}
      />
    </div>
  );
}



==================================================
FILE: ./src/components/ArtifactPanel.tsx
==================================================
'use client';

import React, { useState } from 'react';
import { X, Eye, Code, Copy, Check, Download, RefreshCw, ExternalLink, ChevronDown } from 'lucide-react';
import { Artifact } from '@/types';

interface ArtifactPanelProps {
  artifact: Artifact | null;
  onClose: () => void;
  onRefresh?: () => void;
}

export default function ArtifactPanel({ artifact, onClose, onRefresh }: ArtifactPanelProps) {
  const [viewMode, setViewMode] = useState<'preview' | 'code'>('preview');
  const [copied, setCopied] = useState(false);
  const [showCopyMenu, setShowCopyMenu] = useState(false);

  if (!artifact) return null;

  const canPreview = ['html', 'svg', 'mermaid', 'react'].includes(artifact.type);

  const handleCopy = async () => {
    await navigator.clipboard.writeText(artifact.content);
    setCopied(true);
    setShowCopyMenu(false);
    setTimeout(() => setCopied(false), 2000);
  };

  const handleDownload = () => {
    const ext = getExtension(artifact.type, artifact.language);
    const blob = new Blob([artifact.content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${artifact.name || 'artifact'}.${ext}`;
    a.click();
    URL.revokeObjectURL(url);
    setShowCopyMenu(false);
  };

  const handleOpenInNewTab = () => {
    if (artifact.type === 'html' || artifact.type === 'react') {
      const blob = new Blob([artifact.content], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      window.open(url, '_blank');
    } else if (artifact.type === 'svg') {
      const blob = new Blob([artifact.content], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);
      window.open(url, '_blank');
    }
    setShowCopyMenu(false);
  };

  return (
    <div className="h-full flex flex-col bg-[var(--claude-surface)] border-l border-[var(--claude-border)] animate-slide-in-right">
      {/* Header */}
      <div className="flex items-center justify-between px-4 py-3 border-b border-[var(--claude-border)]">
        <div className="flex items-center gap-3">
          {/* Back button */}
          <button
            onClick={onClose}
            className="p-1.5 rounded-lg hover:bg-[var(--claude-sand-light)] text-[var(--claude-text-secondary)] transition-colors"
          >
            <ChevronDown className="w-4 h-4 rotate-90" />
          </button>

          {/* View toggle */}
          {canPreview && (
            <div className="flex items-center rounded-lg bg-[var(--claude-surface-sunken)] p-1">
              <button
                onClick={() => setViewMode('preview')}
                className={`p-1.5 rounded-md transition-colors ${
                  viewMode === 'preview'
                    ? 'bg-[var(--claude-surface)] shadow-sm'
                    : 'text-[var(--claude-text-muted)] hover:text-[var(--claude-text)]'
                }`}
                title="Preview"
              >
                <Eye className="w-4 h-4" />
              </button>
              <button
                onClick={() => setViewMode('code')}
                className={`p-1.5 rounded-md transition-colors ${
                  viewMode === 'code'
                    ? 'bg-[var(--claude-surface)] shadow-sm'
                    : 'text-[var(--claude-text-muted)] hover:text-[var(--claude-text)]'
                }`}
                title="Code"
              >
                <Code className="w-4 h-4" />
              </button>
            </div>
          )}

          {/* File name */}
          <span className="text-sm text-[var(--claude-text-secondary)]">
            {artifact.name}
            <span className="text-[var(--claude-text-muted)]">
              {'  '}
              {artifact.language?.toUpperCase() || artifact.type.toUpperCase()}
            </span>
          </span>
        </div>

        <div className="flex items-center gap-2">
          {/* Copy dropdown */}
          <div className="relative">
            <button
              onClick={() => setShowCopyMenu(!showCopyMenu)}
              className="flex items-center gap-1.5 px-3 py-1.5 rounded-lg text-sm text-[var(--claude-text-secondary)] hover:bg-[var(--claude-sand-light)] transition-colors"
            >
              {copied ? (
                <>
                  <Check className="w-4 h-4 text-[var(--claude-success)]" />
                  Copied
                </>
              ) : (
                <>
                  Copy
                  <ChevronDown className="w-3 h-3" />
                </>
              )}
            </button>

            {showCopyMenu && (
              <div className="absolute right-0 top-full mt-1 w-44 py-1 rounded-xl bg-[var(--claude-surface)] border border-[var(--claude-border)] shadow-lg z-10">
                <button
                  onClick={handleCopy}
                  className="w-full flex items-center gap-2 px-3 py-2 text-sm text-[var(--claude-text)] hover:bg-[var(--claude-sand-light)]"
                >
                  <Copy className="w-4 h-4" />
                  Copy code
                </button>
                <button
                  onClick={handleDownload}
                  className="w-full flex items-center gap-2 px-3 py-2 text-sm text-[var(--claude-text)] hover:bg-[var(--claude-sand-light)]"
                >
                  <Download className="w-4 h-4" />
                  Download
                </button>
                {canPreview && (
                  <button
                    onClick={handleOpenInNewTab}
                    className="w-full flex items-center gap-2 px-3 py-2 text-sm text-[var(--claude-text)] hover:bg-[var(--claude-sand-light)]"
                  >
                    <ExternalLink className="w-4 h-4" />
                    Open in new tab
                  </button>
                )}
              </div>
            )}
          </div>

          {/* Refresh */}
          {onRefresh && (
            <button
              onClick={onRefresh}
              className="p-1.5 rounded-lg hover:bg-[var(--claude-sand-light)] text-[var(--claude-text-secondary)] transition-colors"
              title="Refresh"
            >
              <RefreshCw className="w-4 h-4" />
            </button>
          )}

          {/* Close */}
          <button
            onClick={onClose}
            className="p-1.5 rounded-lg hover:bg-[var(--claude-sand-light)] text-[var(--claude-text-secondary)] transition-colors"
            title="Close"
          >
            <X className="w-4 h-4" />
          </button>
        </div>
      </div>

      {/* Content */}
      <div className="flex-1 overflow-auto">
        {viewMode === 'preview' && canPreview ? (
          <ArtifactPreview artifact={artifact} />
        ) : (
          <pre className="p-4 text-sm font-mono text-[var(--claude-text)] whitespace-pre-wrap leading-relaxed">
            {artifact.content}
          </pre>
        )}
      </div>
    </div>
  );
}

function ArtifactPreview({ artifact }: { artifact: Artifact }) {
  if (artifact.type === 'svg') {
    return (
      <div
        className="w-full h-full flex items-center justify-center p-4"
        dangerouslySetInnerHTML={{ __html: artifact.content }}
      />
    );
  }

  if (artifact.type === 'html' || artifact.type === 'react') {
    return (
      <iframe
        srcDoc={artifact.content}
        className="w-full h-full border-none"
        sandbox="allow-scripts"
        title={artifact.name}
      />
    );
  }

  if (artifact.type === 'mermaid') {
    // For mermaid, we'd need to integrate mermaid.js
    // For now, show as code
    return (
      <pre className="p-4 text-sm font-mono text-[var(--claude-text)] whitespace-pre-wrap">
        {artifact.content}
      </pre>
    );
  }

  return (
    <pre className="p-4 text-sm font-mono text-[var(--claude-text)] whitespace-pre-wrap">
      {artifact.content}
    </pre>
  );
}

function getExtension(type: string, language?: string): string {
  if (language) {
    const langMap: Record<string, string> = {
      typescript: 'ts',
      javascript: 'js',
      python: 'py',
      tsx: 'tsx',
      jsx: 'jsx',
    };
    return langMap[language] || language;
  }

  const typeMap: Record<string, string> = {
    html: 'html',
    svg: 'svg',
    mermaid: 'mmd',
    react: 'tsx',
    markdown: 'md',
    code: 'txt',
  };
  return typeMap[type] || 'txt';
}



==================================================
FILE: ./src/components/ArtifactsList.tsx
==================================================
'use client';

import React from 'react';
import { Download, FileCode, FileText, Image, Box, GitBranch } from 'lucide-react';
import { Artifact } from '@/types';

interface ArtifactsListProps {
  artifacts: Artifact[];
  onSelect: (artifact: Artifact) => void;
  onDownloadAll: () => void;
}

export default function ArtifactsList({ artifacts, onSelect, onDownloadAll }: ArtifactsListProps) {
  if (artifacts.length === 0) return null;

  const getIcon = (type: string) => {
    switch (type) {
      case 'html':
      case 'react':
        return FileCode;
      case 'svg':
        return Image;
      case 'mermaid':
        return GitBranch;
      case 'markdown':
        return FileText;
      default:
        return Box;
    }
  };

  const getTypeLabel = (artifact: Artifact) => {
    if (artifact.language) {
      return artifact.language.toUpperCase();
    }
    const typeLabels: Record<string, string> = {
      code: 'Code',
      html: 'HTML',
      svg: 'SVG',
      mermaid: 'Mermaid',
      react: 'React',
      markdown: 'MD',
    };
    return typeLabels[artifact.type] || artifact.type.toUpperCase();
  };

  const handleDownload = (e: React.MouseEvent, artifact: Artifact) => {
    e.stopPropagation();
    const ext = getExtension(artifact.type, artifact.language);
    const blob = new Blob([artifact.content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${artifact.name || 'artifact'}.${ext}`;
    a.click();
    URL.revokeObjectURL(url);
  };

  return (
    <div className="w-72 h-full bg-[var(--claude-surface)] border-l border-[var(--claude-border)] flex flex-col">
      {/* Header */}
      <div className="flex items-center justify-between px-4 py-3 border-b border-[var(--claude-border)]">
        <span className="font-medium text-[var(--claude-text)]">Artifacts</span>
        <button
          onClick={onDownloadAll}
          className="flex items-center gap-1.5 text-sm text-[var(--claude-text-secondary)] hover:text-[var(--claude-text)] transition-colors"
        >
          <Download className="w-4 h-4" />
          Download all
        </button>
      </div>

      {/* List */}
      <div className="flex-1 overflow-y-auto p-2">
        <div className="space-y-1">
          {artifacts.map((artifact) => {
            const Icon = getIcon(artifact.type);
            return (
              <button
                key={artifact.id}
                onClick={() => onSelect(artifact)}
                className="w-full flex items-center gap-3 p-3 rounded-xl hover:bg-[var(--claude-sand-light)] transition-colors text-left group"
              >
                <div className="p-2 rounded-lg bg-[var(--claude-surface-sunken)]">
                  <Icon className="w-4 h-4 text-[var(--claude-text-muted)]" />
                </div>
                <div className="flex-1 min-w-0">
                  <p className="text-sm font-medium text-[var(--claude-text)] truncate">
                    {artifact.name}
                  </p>
                  <p className="text-xs text-[var(--claude-text-muted)]">
                    {getTypeLabel(artifact)}
                  </p>
                </div>
                <button
                  onClick={(e) => handleDownload(e, artifact)}
                  className="p-1.5 rounded-lg opacity-0 group-hover:opacity-100 hover:bg-[var(--claude-sand)] text-[var(--claude-text-muted)] transition-all"
                >
                  <Download className="w-4 h-4" />
                </button>
              </button>
            );
          })}
        </div>
      </div>
    </div>
  );
}

function getExtension(type: string, language?: string): string {
  if (language) {
    const langMap: Record<string, string> = {
      typescript: 'ts',
      javascript: 'js',
      python: 'py',
      tsx: 'tsx',
      jsx: 'jsx',
    };
    return langMap[language] || language;
  }

  const typeMap: Record<string, string> = {
    html: 'html',
    svg: 'svg',
    mermaid: 'mmd',
    react: 'tsx',
    markdown: 'md',
    code: 'txt',
  };
  return typeMap[type] || 'txt';
}



==================================================
FILE: ./src/components/BranchManager.tsx
==================================================
'use client';

import React, { useState } from 'react';
import { GitBranch, GitMerge, Trash2, Plus, AlertCircle, Check, ExternalLink } from 'lucide-react';

interface BranchManagerProps {
  currentBranch: string;
  branches: string[];
  defaultBranch: string;
  onCreateBranch: (name: string) => Promise<void>;
  onDeleteBranch: (name: string) => Promise<void>;
  onSwitchBranch: (name: string) => void;
  onCreatePR: (branch: string) => Promise<{ url: string; number: number } | null>;
}

export default function BranchManager({
  currentBranch,
  branches,
  defaultBranch,
  onCreateBranch,
  onDeleteBranch,
  onSwitchBranch,
  onCreatePR,
}: BranchManagerProps) {
  const [isCreating, setIsCreating] = useState(false);
  const [newBranchName, setNewBranchName] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleCreate = async () => {
    if (!newBranchName.trim()) return;
    
    setIsLoading(true);
    setError(null);
    
    try {
      await onCreateBranch(newBranchName.trim());
      setNewBranchName('');
      setIsCreating(false);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to create branch');
    } finally {
      setIsLoading(false);
    }
  };

  const handleDelete = async (branch: string) => {
    if (!confirm(`Delete branch "${branch}"? This cannot be undone.`)) return;
    
    setIsLoading(true);
    setError(null);
    
    try {
      await onDeleteBranch(branch);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to delete branch');
    } finally {
      setIsLoading(false);
    }
  };

  const handleCreatePR = async (branch: string) => {
    setIsLoading(true);
    setError(null);
    
    try {
      const result = await onCreatePR(branch);
      if (result) {
        window.open(result.url, '_blank');
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to create PR');
    } finally {
      setIsLoading(false);
    }
  };

  const featureBranches = branches.filter(b => b !== defaultBranch);

  return (
    <div className="p-4 rounded-xl bg-[var(--claude-surface)] border border-[var(--claude-border)]">
      {/* Header */}
      <div className="flex items-center justify-between mb-4">
        <div className="flex items-center gap-2">
          <GitBranch className="w-5 h-5 text-[var(--claude-terracotta)]" />
          <h3 className="font-medium text-[var(--claude-text)]">Branches</h3>
        </div>
        <button
          onClick={() => setIsCreating(true)}
          className="flex items-center gap-1.5 px-3 py-1.5 rounded-lg text-sm bg-[var(--claude-terracotta)] text-white hover:bg-[var(--claude-terracotta-hover)] transition-colors"
        >
          <Plus className="w-4 h-4" />
          New
        </button>
      </div>

      {/* Error */}
      {error && (
        <div className="mb-4 p-3 rounded-lg bg-[var(--claude-error)]/10 border border-[var(--claude-error)]/20 flex items-center gap-2 text-sm text-[var(--claude-error)]">
          <AlertCircle className="w-4 h-4 flex-shrink-0" />
          {error}
        </div>
      )}

      {/* New branch form */}
      {isCreating && (
        <div className="mb-4 p-3 rounded-lg bg-[var(--claude-surface-sunken)] border border-[var(--claude-border)]">
          <input
            type="text"
            value={newBranchName}
            onChange={(e) => setNewBranchName(e.target.value)}
            placeholder="feature/my-branch"
            className="w-full px-3 py-2 rounded-lg bg-[var(--claude-surface)] border border-[var(--claude-border)] text-sm text-[var(--claude-text)] placeholder:text-[var(--claude-text-muted)] focus:outline-none focus:border-[var(--claude-terracotta)] mb-2"
            onKeyDown={(e) => e.key === 'Enter' && handleCreate()}
            autoFocus
          />
          <div className="flex items-center gap-2">
            <button
              onClick={handleCreate}
              disabled={!newBranchName.trim() || isLoading}
              className="px-3 py-1.5 rounded-lg text-sm bg-[var(--claude-terracotta)] text-white hover:bg-[var(--claude-terracotta-hover)] disabled:opacity-50 transition-colors"
            >
              Create
            </button>
            <button
              onClick={() => {
                setIsCreating(false);
                setNewBranchName('');
              }}
              className="px-3 py-1.5 rounded-lg text-sm text-[var(--claude-text-secondary)] hover:bg-[var(--claude-sand-light)] transition-colors"
            >
              Cancel
            </button>
          </div>
        </div>
      )}

      {/* Branch list */}
      <div className="space-y-2">
        {/* Default branch */}
        <div
          onClick={() => onSwitchBranch(defaultBranch)}
          className={`
            flex items-center gap-3 p-3 rounded-lg cursor-pointer transition-colors
            ${currentBranch === defaultBranch
              ? 'bg-[var(--claude-terracotta-subtle)] border border-[var(--claude-terracotta)]/20'
              : 'hover:bg-[var(--claude-sand-light)] border border-transparent'
            }
          `}
        >
          <GitBranch className="w-4 h-4 text-[var(--claude-text-muted)]" />
          <span className="flex-1 text-sm font-medium text-[var(--claude-text)]">
            {defaultBranch}
          </span>
          <span className="text-xs text-[var(--claude-text-muted)]">default</span>
          {currentBranch === defaultBranch && (
            <Check className="w-4 h-4 text-[var(--claude-success)]" />
          )}
        </div>

        {/* Feature branches */}
        {featureBranches.map((branch) => (
          <div
            key={branch}
            className={`
              flex items-center gap-3 p-3 rounded-lg transition-colors
              ${currentBranch === branch
                ? 'bg-[var(--claude-terracotta-subtle)] border border-[var(--claude-terracotta)]/20'
                : 'hover:bg-[var(--claude-sand-light)] border border-transparent'
              }
            `}
          >
            <div
              onClick={() => onSwitchBranch(branch)}
              className="flex items-center gap-3 flex-1 cursor-pointer"
            >
              <GitBranch className="w-4 h-4 text-[var(--claude-text-muted)]" />
              <span className="text-sm font-medium text-[var(--claude-text)] truncate">
                {branch}
              </span>
              {currentBranch === branch && (
                <Check className="w-4 h-4 text-[var(--claude-success)]" />
              )}
            </div>
            <div className="flex items-center gap-1">
              <button
                onClick={() => handleCreatePR(branch)}
                className="p-1.5 rounded-lg hover:bg-[var(--claude-sand)] text-[var(--claude-text-muted)] hover:text-[var(--claude-success)] transition-colors"
                title="Create PR"
              >
                <GitMerge className="w-4 h-4" />
              </button>
              <button
                onClick={() => handleDelete(branch)}
                className="p-1.5 rounded-lg hover:bg-[var(--claude-sand)] text-[var(--claude-text-muted)] hover:text-[var(--claude-error)] transition-colors"
                title="Delete branch"
              >
                <Trash2 className="w-4 h-4" />
              </button>
            </div>
          </div>
        ))}

        {featureBranches.length === 0 && (
          <p className="text-sm text-[var(--claude-text-muted)] text-center py-4">
            No feature branches yet
          </p>
        )}
      </div>
    </div>
  );
}



==================================================
FILE: ./src/components/ChatMessage.tsx
==================================================
'use client';

import React from 'react';
import ReactMarkdown from 'react-markdown';
import { User, Sparkles } from 'lucide-react';
import { Message } from '@/types';
import ThinkingBlock from './ThinkingBlock';
import CodeBlock from './CodeBlock';
import CostTracker from './CostTracker';
import PostEditActions from './PostEditActions';
import Citations from './Citations';

interface ChatMessageProps {
  message: Message;
  onViewPR?: () => void;
  onDiscard?: () => void;
}

export default function ChatMessage({ message, onViewPR, onDiscard }: ChatMessageProps) {
  const isUser = message.role === 'user';

  return (
    <div className={`py-6 px-4 ${isUser ? 'bg-transparent' : 'bg-[var(--claude-surface-sunken)]/50'}`}>
      <div className="max-w-3xl mx-auto">
        <div className="flex gap-4">
          {/* Avatar */}
          <div className={`
            flex-shrink-0 w-8 h-8 rounded-full flex items-center justify-center
            ${isUser
              ? 'bg-[var(--claude-sand-light)]'
              : 'bg-gradient-to-br from-[var(--claude-terracotta)] to-[#E89B7D]'
            }
          `}>
            {isUser ? (
              <User className="w-4 h-4 text-[var(--claude-text-secondary)]" />
            ) : (
              <Sparkles className="w-4 h-4 text-white" />
            )}
          </div>

          {/* Content */}
          <div className="flex-1 min-w-0">
            {/* Role label */}
            <p className="text-sm font-medium text-[var(--claude-text-secondary)] mb-2">
              {isUser ? 'You' : 'Claude'}
            </p>

            {/* Thinking block */}
            {message.thinkingContent && (
              <ThinkingBlock
                content={message.thinkingContent}
                isStreaming={message.isStreaming}
              />
            )}

            {/* Message content */}
            <div className="prose max-w-none">
              <ReactMarkdown
                components={{
                  code({ className, children, ...props }) {
                    const match = /language-(\w+)/.exec(className || '');
                    const isInline = !match;
                    
                    if (isInline) {
                      return (
                        <code className={className} {...props}>
                          {children}
                        </code>
                      );
                    }

                    return (
                      <CodeBlock
                        code={String(children).replace(/\n$/, '')}
                        language={match?.[1] || 'text'}
                      />
                    );
                  },
                }}
              >
                {message.content}
              </ReactMarkdown>
            </div>

            {/* Loading indicator */}
            {message.isStreaming && !message.content && (
              <div className="flex items-center gap-2 text-[var(--claude-text-muted)]">
                <div className="w-2 h-2 rounded-full bg-[var(--claude-terracotta)] animate-pulse" />
                <span className="text-sm">Thinking...</span>
              </div>
            )}

            {/* File changes */}
            {message.filesChanged && message.filesChanged.length > 0 && (
              <PostEditActions
                state={{
                  mode: 'safe',
                  filesChanged: message.filesChanged,
                  totalAdditions: message.filesChanged.reduce((sum, f) => sum + (f.additions || 0), 0),
                  totalDeletions: message.filesChanged.reduce((sum, f) => sum + (f.deletions || 0), 0),
                  status: 'pushed',
                }}
                onViewPR={onViewPR}
                onDiscard={onDiscard}
              />
            )}

            {/* Citations from web search */}
            {message.citations && message.citations.length > 0 && (
              <Citations citations={message.citations} />
            )}

            {/* Cost tracker */}
            {!isUser && message.cost !== undefined && (
              <div className="mt-4">
                <CostTracker
                  cost={message.cost}
                  savedPercent={message.savedPercent}
                  compact
                />
              </div>
            )}

            {/* Uploaded files indicator */}
            {message.files && message.files.length > 0 && (
              <div className="mt-3 flex flex-wrap gap-2">
                {message.files.map((file, index) => (
                  <span
                    key={index}
                    className="inline-flex items-center gap-1.5 px-2.5 py-1 rounded-lg bg-[var(--claude-sand-light)] text-xs text-[var(--claude-text-secondary)]"
                  >
                     {file.name}
                  </span>
                ))}
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}



==================================================
FILE: ./src/components/Citations.tsx
==================================================
'use client';

import React from 'react';
import { ExternalLink } from 'lucide-react';
import { Citation } from '@/types';

interface CitationsProps {
  citations: Citation[];
}

export default function Citations({ citations }: CitationsProps) {
  if (citations.length === 0) return null;

  // Dedupe citations by URL
  const uniqueCitations = citations.filter((cite, index, self) =>
    index === self.findIndex(c => c.url === cite.url)
  );

  return (
    <div className="mt-4 p-3 rounded-xl bg-[var(--claude-surface-sunken)] border border-[var(--claude-border)]">
      <p className="text-xs font-medium text-[var(--claude-text-muted)] uppercase tracking-wide mb-2">
        Sources
      </p>
      <div className="space-y-2">
        {uniqueCitations.map((citation, index) => (
          <a
            key={index}
            href={citation.url}
            target="_blank"
            rel="noopener noreferrer"
            className="flex items-start gap-2 text-sm text-[var(--claude-text-secondary)] hover:text-[var(--claude-terracotta)] transition-colors group"
          >
            <ExternalLink className="w-3.5 h-3.5 mt-0.5 flex-shrink-0 opacity-50 group-hover:opacity-100" />
            <div className="min-w-0 flex-1">
              <p className="font-medium truncate group-hover:underline">
                {citation.title || new URL(citation.url).hostname}
              </p>
              {citation.snippet && (
                <p className="text-xs text-[var(--claude-text-muted)] line-clamp-2 mt-0.5">
                  {citation.snippet}
                </p>
              )}
            </div>
          </a>
        ))}
      </div>
    </div>
  );
}



==================================================
FILE: ./src/components/CodeBlock.tsx
==================================================
'use client';

import React, { useState } from 'react';
import { Check, Copy, FileCode } from 'lucide-react';

interface CodeBlockProps {
  code: string;
  language?: string;
  filename?: string;
}

export default function CodeBlock({ code, language = 'text', filename }: CodeBlockProps) {
  const [copied, setCopied] = useState(false);

  const handleCopy = async () => {
    await navigator.clipboard.writeText(code);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };

  return (
    <div className="my-4 rounded-xl border border-[var(--claude-border)] overflow-hidden bg-[var(--claude-surface-sunken)]">
      {/* Header */}
      <div className="flex items-center justify-between px-4 py-2 border-b border-[var(--claude-border)] bg-[var(--claude-surface)]">
        <div className="flex items-center gap-2">
          <FileCode className="w-4 h-4 text-[var(--claude-text-muted)]" />
          <span className="text-sm text-[var(--claude-text-muted)]">
            {filename || language}
          </span>
        </div>
        <button
          onClick={handleCopy}
          className="flex items-center gap-1.5 px-2.5 py-1 rounded-lg text-sm text-[var(--claude-text-secondary)] hover:bg-[var(--claude-sand-light)] transition-colors"
        >
          {copied ? (
            <>
              <Check className="w-3.5 h-3.5 text-[var(--claude-success)]" />
              <span className="text-[var(--claude-success)]">Copied!</span>
            </>
          ) : (
            <>
              <Copy className="w-3.5 h-3.5" />
              <span>Copy</span>
            </>
          )}
        </button>
      </div>

      {/* Code */}
      <pre className="p-4 overflow-x-auto">
        <code className="text-sm font-mono text-[var(--claude-text)] leading-relaxed">
          {code}
        </code>
      </pre>
    </div>
  );
}



==================================================
FILE: ./src/components/CostTracker.tsx
==================================================
'use client';

import React from 'react';
import { DollarSign, TrendingDown } from 'lucide-react';

interface CostTrackerProps {
  cost: number;
  savedPercent?: number;
  sessionTotal?: number;
  compact?: boolean;
}

export default function CostTracker({
  cost,
  savedPercent = 0,
  sessionTotal,
  compact = false,
}: CostTrackerProps) {
  const formatCost = (value: number) => {
    if (value < 0.01) return '<$0.01';
    return `$${value.toFixed(2)}`;
  };

  if (compact) {
    return (
      <div className="inline-flex items-center gap-2 text-xs text-[var(--claude-text-muted)]">
        <span>{formatCost(cost)}</span>
        {savedPercent > 0 && (
          <span className="text-[var(--claude-success)]">
            saved {savedPercent}%
          </span>
        )}
      </div>
    );
  }

  return (
    <div className="flex items-center gap-4 px-4 py-2 rounded-xl bg-[var(--claude-surface-sunken)] border border-[var(--claude-border)]">
      {/* Current message cost */}
      <div className="flex items-center gap-2">
        <DollarSign className="w-4 h-4 text-[var(--claude-text-muted)]" />
        <div>
          <p className="text-sm font-medium text-[var(--claude-text)]">
            {formatCost(cost)}
          </p>
          <p className="text-xs text-[var(--claude-text-muted)]">this message</p>
        </div>
      </div>

      {/* Cache savings */}
      {savedPercent > 0 && (
        <div className="flex items-center gap-2">
          <TrendingDown className="w-4 h-4 text-[var(--claude-success)]" />
          <div>
            <p className="text-sm font-medium text-[var(--claude-success)]">
              {savedPercent}% saved
            </p>
            <p className="text-xs text-[var(--claude-text-muted)]">from cache</p>
          </div>
        </div>
      )}

      {/* Session total */}
      {sessionTotal !== undefined && (
        <div className="ml-auto text-right">
          <p className="text-sm font-medium text-[var(--claude-text)]">
            {formatCost(sessionTotal)}
          </p>
          <p className="text-xs text-[var(--claude-text-muted)]">session total</p>
        </div>
      )}
    </div>
  );
}



==================================================
FILE: ./src/components/FileUpload.tsx
==================================================
'use client';

import React, { useRef, useState } from 'react';
import { Upload, X, FileText, Image, File } from 'lucide-react';
import { UploadedFile } from '@/types';

interface FileUploadProps {
  files: UploadedFile[];
  onFilesChange: (files: UploadedFile[]) => void;
  maxFiles?: number;
  maxSizeMB?: number;
}

export default function FileUpload({
  files,
  onFilesChange,
  maxFiles = 5,
  maxSizeMB = 10,
}: FileUploadProps) {
  const inputRef = useRef<HTMLInputElement>(null);
  const [isDragging, setIsDragging] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleFiles = async (fileList: FileList | null) => {
    if (!fileList) return;
    setError(null);

    const newFiles: UploadedFile[] = [];

    for (const file of Array.from(fileList)) {
      // Check file count
      if (files.length + newFiles.length >= maxFiles) {
        setError(`Maximum ${maxFiles} files allowed`);
        break;
      }

      // Check file size
      if (file.size > maxSizeMB * 1024 * 1024) {
        setError(`File ${file.name} exceeds ${maxSizeMB}MB limit`);
        continue;
      }

      // Read file as base64
      try {
        const base64 = await readFileAsBase64(file);
        newFiles.push({
          name: file.name,
          type: file.type,
          size: file.size,
          base64,
        });
      } catch {
        setError(`Failed to read ${file.name}`);
      }
    }

    if (newFiles.length > 0) {
      onFilesChange([...files, ...newFiles]);
    }
  };

  const readFileAsBase64 = (file: File): Promise<string> => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => {
        const result = reader.result as string;
        // Remove data URL prefix
        const base64 = result.split(',')[1];
        resolve(base64);
      };
      reader.onerror = reject;
      reader.readAsDataURL(file);
    });
  };

  const removeFile = (index: number) => {
    const newFiles = [...files];
    newFiles.splice(index, 1);
    onFilesChange(newFiles);
  };

  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(true);
  };

  const handleDragLeave = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(false);
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(false);
    handleFiles(e.dataTransfer.files);
  };

  const getFileIcon = (type: string) => {
    if (type.startsWith('image/')) return Image;
    if (type.startsWith('text/')) return FileText;
    return File;
  };

  const formatSize = (bytes: number) => {
    if (bytes < 1024) return `${bytes} B`;
    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
    return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
  };

  return (
    <div className="space-y-3">
      {/* Upload area */}
      <div
        onClick={() => inputRef.current?.click()}
        onDragOver={handleDragOver}
        onDragLeave={handleDragLeave}
        onDrop={handleDrop}
        className={`
          relative flex items-center justify-center gap-2 px-4 py-3 rounded-xl border-2 border-dashed
          cursor-pointer transition-all
          ${isDragging
            ? 'border-[var(--claude-terracotta)] bg-[var(--claude-terracotta-subtle)]'
            : 'border-[var(--claude-border)] hover:border-[var(--claude-border-strong)] hover:bg-[var(--claude-surface-sunken)]'
          }
        `}
      >
        <Upload className="w-4 h-4 text-[var(--claude-text-muted)]" />
        <span className="text-sm text-[var(--claude-text-secondary)]">
          Drop files or click to upload
        </span>
        <input
          ref={inputRef}
          type="file"
          multiple
          className="hidden"
          onChange={(e) => handleFiles(e.target.files)}
          accept=".txt,.md,.json,.js,.ts,.jsx,.tsx,.py,.css,.html,.xml,.yaml,.yml,.csv,.log,.sh,.bat,.ps1,.sql,.png,.jpg,.jpeg,.gif,.webp,.pdf"
        />
      </div>

      {/* Error */}
      {error && (
        <p className="text-sm text-[var(--claude-error)]">{error}</p>
      )}

      {/* File list */}
      {files.length > 0 && (
        <div className="space-y-2">
          {files.map((file, index) => {
            const Icon = getFileIcon(file.type);
            return (
              <div
                key={index}
                className="flex items-center gap-3 px-3 py-2 rounded-lg bg-[var(--claude-surface-sunken)] border border-[var(--claude-border)]"
              >
                <Icon className="w-4 h-4 text-[var(--claude-text-muted)]" />
                <div className="flex-1 min-w-0">
                  <p className="text-sm font-medium text-[var(--claude-text)] truncate">
                    {file.name}
                  </p>
                  <p className="text-xs text-[var(--claude-text-muted)]">
                    {formatSize(file.size)}
                  </p>
                </div>
                <button
                  onClick={() => removeFile(index)}
                  className="p-1 rounded-lg hover:bg-[var(--claude-sand-light)] text-[var(--claude-text-muted)] hover:text-[var(--claude-error)] transition-colors"
                >
                  <X className="w-4 h-4" />
                </button>
              </div>
            );
          })}
        </div>
      )}
    </div>
  );
}



==================================================
FILE: ./src/components/LoadingSpinner.tsx
==================================================
'use client';

import React from 'react';

interface LoadingSpinnerProps {
  size?: 'sm' | 'md' | 'lg';
  className?: string;
}

export default function LoadingSpinner({ size = 'md', className = '' }: LoadingSpinnerProps) {
  const sizeClasses = {
    sm: 'w-4 h-4 border-2',
    md: 'w-6 h-6 border-2',
    lg: 'w-10 h-10 border-3',
  };

  return (
    <div
      className={`${sizeClasses[size]} rounded-full border-[var(--claude-terracotta-subtle)] border-t-[var(--claude-terracotta)] animate-spin ${className}`}
      role="status"
      aria-label="Loading"
    />
  );
}



==================================================
FILE: ./src/components/PostEditActions.tsx
==================================================
'use client';

import React from 'react';
import { ExternalLink, Trash2, Check, X, GitBranch, FileCode, Plus, Minus } from 'lucide-react';
import { PostEditState, FileChange } from '@/types';

interface PostEditActionsProps {
  state: PostEditState;
  onViewPR?: () => void;
  onDiscard?: () => void;
  onConfirm?: () => void;
  onCancel?: () => void;
}

export default function PostEditActions({
  state,
  onViewPR,
  onDiscard,
  onConfirm,
  onCancel,
}: PostEditActionsProps) {
  const { mode, branch, filesChanged, totalAdditions, totalDeletions, prUrl, previewUrl, status } = state;

  return (
    <div className="rounded-2xl border border-[var(--claude-border)] bg-[var(--claude-surface)] p-5 shadow-sm animate-fade-in-up">
      {/* Header */}
      <div className="flex items-center gap-3 mb-4">
        {mode === 'safe' ? (
          <>
            <div className="p-2 rounded-lg bg-[var(--claude-success)]/10">
              <GitBranch className="w-5 h-5 text-[var(--claude-success)]" />
            </div>
            <div>
              <p className="font-medium text-[var(--claude-text)]">
                {status === 'pushed' ? 'Changes pushed to branch' : 'Ready to push'}
              </p>
              {branch && (
                <p className="text-sm text-[var(--claude-text-secondary)]">
                  Branch: <code className="px-1.5 py-0.5 rounded bg-[var(--claude-sand-light)] text-[var(--claude-terracotta)]">{branch}</code>
                </p>
              )}
            </div>
          </>
        ) : (
          <>
            <div className="p-2 rounded-lg bg-[var(--claude-warning)]/10">
              <FileCode className="w-5 h-5 text-[var(--claude-warning)]" />
            </div>
            <div>
              <p className="font-medium text-[var(--claude-text)]">
                Direct Mode: Push to main
              </p>
              <p className="text-sm text-[var(--claude-text-secondary)]">
                Changes will be applied immediately
              </p>
            </div>
          </>
        )}
      </div>

      {/* Files changed */}
      {filesChanged.length > 0 && (
        <div className="mb-4 p-3 rounded-xl bg-[var(--claude-surface-sunken)] border border-[var(--claude-border)]">
          <p className="text-xs font-medium text-[var(--claude-text-muted)] uppercase tracking-wide mb-2">
            Files changed
          </p>
          <div className="space-y-1.5">
            {filesChanged.map((file, index) => (
              <FileChangeItem key={index} file={file} />
            ))}
          </div>
          <div className="mt-3 pt-3 border-t border-[var(--claude-border)] flex items-center gap-4 text-sm">
            <span className="flex items-center gap-1 text-[var(--claude-success)]">
              <Plus className="w-3.5 h-3.5" />
              {totalAdditions}
            </span>
            <span className="flex items-center gap-1 text-[var(--claude-error)]">
              <Minus className="w-3.5 h-3.5" />
              {totalDeletions}
            </span>
          </div>
        </div>
      )}

      {/* Preview URL */}
      {previewUrl && (
        <div className="mb-4 p-3 rounded-xl bg-[var(--claude-terracotta-subtle)] border border-[var(--claude-terracotta)]/20">
          <p className="text-xs font-medium text-[var(--claude-terracotta)] mb-1">Preview available</p>
          <a
            href={previewUrl}
            target="_blank"
            rel="noopener noreferrer"
            className="text-sm text-[var(--claude-terracotta)] hover:underline break-all"
          >
            {previewUrl}
          </a>
        </div>
      )}

      {/* Actions */}
      <div className="flex items-center gap-3">
        {mode === 'safe' ? (
          <>
            <button
              onClick={onViewPR}
              className="flex-1 flex items-center justify-center gap-2 px-4 py-2.5 rounded-xl bg-[var(--claude-terracotta)] text-white font-medium hover:bg-[var(--claude-terracotta-hover)] transition-colors"
            >
              <ExternalLink className="w-4 h-4" />
              View PR
            </button>
            <button
              onClick={onDiscard}
              className="flex items-center justify-center gap-2 px-4 py-2.5 rounded-xl border border-[var(--claude-border)] text-[var(--claude-text-secondary)] hover:bg-[var(--claude-surface-sunken)] transition-colors"
            >
              <Trash2 className="w-4 h-4" />
              Discard
            </button>
          </>
        ) : (
          <>
            <button
              onClick={onConfirm}
              className="flex-1 flex items-center justify-center gap-2 px-4 py-2.5 rounded-xl bg-[var(--claude-terracotta)] text-white font-medium hover:bg-[var(--claude-terracotta-hover)] transition-colors"
            >
              <Check className="w-4 h-4" />
              Confirm Push
            </button>
            <button
              onClick={onCancel}
              className="flex items-center justify-center gap-2 px-4 py-2.5 rounded-xl border border-[var(--claude-border)] text-[var(--claude-text-secondary)] hover:bg-[var(--claude-surface-sunken)] transition-colors"
            >
              <X className="w-4 h-4" />
              Cancel
            </button>
          </>
        )}
      </div>
    </div>
  );
}

function FileChangeItem({ file }: { file: FileChange }) {
  return (
    <div className="flex items-center gap-2 text-sm font-mono">
      <span className={`
        px-1.5 py-0.5 rounded text-xs font-medium
        ${file.action === 'create' ? 'bg-[var(--claude-success)]/10 text-[var(--claude-success)]' : ''}
        ${file.action === 'edit' ? 'bg-[var(--claude-warning)]/10 text-[var(--claude-warning)]' : ''}
        ${file.action === 'delete' ? 'bg-[var(--claude-error)]/10 text-[var(--claude-error)]' : ''}
      `}>
        {file.action === 'create' ? 'A' : file.action === 'edit' ? 'M' : 'D'}
      </span>
      <span className="text-[var(--claude-text-secondary)] truncate">{file.path}</span>
      {(file.additions || file.deletions) && (
        <span className="ml-auto flex items-center gap-2 text-xs">
          {file.additions && (
            <span className="text-[var(--claude-success)]">+{file.additions}</span>
          )}
          {file.deletions && (
            <span className="text-[var(--claude-error)]">-{file.deletions}</span>
          )}
        </span>
      )}
    </div>
  );
}



==================================================
FILE: ./src/components/QuickSettings.tsx
==================================================
'use client';

import React from 'react';
import { X, Shield, Zap, Database, Brain, Terminal, FileUp, Settings } from 'lucide-react';
import { Settings as SettingsType, EffortLevel, ModelType, MODEL_DISPLAY_NAMES } from '@/types';

interface QuickSettingsProps {
  isOpen: boolean;
  onClose: () => void;
  settings: SettingsType;
  onSettingsChange: (settings: SettingsType) => void;
  onOpenFullSettings: () => void;
}

export default function QuickSettings({
  isOpen,
  onClose,
  settings,
  onSettingsChange,
  onOpenFullSettings,
}: QuickSettingsProps) {
  if (!isOpen) return null;

  const updateSetting = <K extends keyof SettingsType>(key: K, value: SettingsType[K]) => {
    onSettingsChange({ ...settings, [key]: value });
  };

  return (
    <div className="absolute bottom-full left-0 mb-2 w-80 rounded-xl bg-[var(--claude-surface)] border border-[var(--claude-border)] shadow-lg z-50 animate-fade-in-up">
      {/* Header */}
      <div className="flex items-center justify-between px-4 py-3 border-b border-[var(--claude-border)]">
        <div className="flex items-center gap-2">
          <Settings className="w-4 h-4 text-[var(--claude-terracotta)]" />
          <span className="font-medium text-sm text-[var(--claude-text)]">Quick Settings</span>
        </div>
        <button
          onClick={onClose}
          className="p-1 rounded hover:bg-[var(--claude-sand-light)] text-[var(--claude-text-muted)]"
        >
          <X className="w-4 h-4" />
        </button>
      </div>

      {/* Content */}
      <div className="p-4 space-y-5">
        {/* Effort */}
        <div>
          <label className="block text-xs font-medium text-[var(--claude-text-muted)] uppercase tracking-wide mb-2">
            Effort
          </label>
          <div className="grid grid-cols-3 gap-2">
            {(['low', 'medium', 'high'] as EffortLevel[]).map((level) => (
              <button
                key={level}
                onClick={() => updateSetting('effort', level)}
                className={`px-3 py-2 rounded-lg text-xs font-medium capitalize transition-all ${
                  settings.effort === level
                    ? 'bg-[var(--claude-terracotta)] text-white'
                    : 'bg-[var(--claude-surface-sunken)] text-[var(--claude-text-secondary)] hover:bg-[var(--claude-sand-light)]'
                }`}
              >
                {level} {level === 'low' ? '' : level === 'medium' ? '' : ''}
              </button>
            ))}
          </div>
          <p className="text-xs text-[var(--claude-text-muted)] mt-1">
            Controls response depth & thinking budget
          </p>
        </div>

        {/* Deploy Mode */}
        <div>
          <label className="block text-xs font-medium text-[var(--claude-text-muted)] uppercase tracking-wide mb-2">
            Deploy Mode
          </label>
          <div className="grid grid-cols-2 gap-2">
            <button
              onClick={() => updateSetting('deployMode', 'safe')}
              className={`flex items-center justify-center gap-2 px-3 py-2 rounded-lg text-xs font-medium transition-all ${
                settings.deployMode === 'safe'
                  ? 'bg-[var(--claude-success)]/10 border border-[var(--claude-success)] text-[var(--claude-success)]'
                  : 'bg-[var(--claude-surface-sunken)] text-[var(--claude-text-secondary)] hover:bg-[var(--claude-sand-light)]'
              }`}
            >
              <Shield className="w-3 h-3" /> Safe (PR)
            </button>
            <button
              onClick={() => updateSetting('deployMode', 'direct')}
              className={`flex items-center justify-center gap-2 px-3 py-2 rounded-lg text-xs font-medium transition-all ${
                settings.deployMode === 'direct'
                  ? 'bg-[var(--claude-warning)]/10 border border-[var(--claude-warning)] text-[var(--claude-warning)]'
                  : 'bg-[var(--claude-surface-sunken)] text-[var(--claude-text-secondary)] hover:bg-[var(--claude-sand-light)]'
              }`}
            >
              <Zap className="w-3 h-3" /> Direct
            </button>
          </div>
          <p className="text-xs text-[var(--claude-text-muted)] mt-1">
            {settings.deployMode === 'safe'
              ? 'Safe: branch  PR  review'
              : 'Direct: push straight to main'}
          </p>
        </div>

        {/* Divider */}
        <div className="border-t border-[var(--claude-border)]" />

        {/* Saves Money Section */}
        <div>
          <label className="block text-xs font-medium text-[var(--claude-success)] uppercase tracking-wide mb-2">
             Saves Money
          </label>

          <ToggleRow
            checked={settings.enableContextCompaction}
            onChange={(checked) => updateSetting('enableContextCompaction', checked)}
            label="Context Compaction"
            badge="Saves 30-50%"
            description="Summarizes old messages in long chats"
          />

          <ToggleRow
            checked={settings.enableMemory}
            onChange={(checked) => updateSetting('enableMemory', checked)}
            label="Memory"
            badge="Saves 10-20%"
            description="Remembers key facts across sessions"
          />

          <ToggleRow
            checked={settings.enableFilesApi}
            onChange={(checked) => updateSetting('enableFilesApi', checked)}
            label="Files API"
            badge="Saves 80%"
            description="Upload once, reference many times"
          />
        </div>

        {/* Divider */}
        <div className="border-t border-[var(--claude-border)]" />

        {/* Costs More Section */}
        <div>
          <label className="block text-xs font-medium text-[var(--claude-warning)] uppercase tracking-wide mb-2">
             Costs More
          </label>

          <ToggleRow
            checked={settings.enableInterleavedThinking}
            onChange={(checked) => updateSetting('enableInterleavedThinking', checked)}
            label="Interleaved Thinking"
            badge=" +50-100%"
            description="Re-thinks after each tool result"
          />

          <ToggleRow
            checked={settings.enableCodeExecution}
            onChange={(checked) => updateSetting('enableCodeExecution', checked)}
            label="Code Execution"
            badge=" +$0.05-0.20"
            description="Runs Python/JS in sandbox"
          />
        </div>
      </div>

      {/* Footer */}
      <div className="px-4 py-3 border-t border-[var(--claude-border)]">
        <button
          onClick={onOpenFullSettings}
          className="w-full text-center text-sm text-[var(--claude-terracotta)] hover:underline"
        >
          Open Full Settings 
        </button>
      </div>
    </div>
  );
}

// Toggle row component
function ToggleRow({
  checked,
  onChange,
  label,
  badge,
  description,
}: {
  checked: boolean;
  onChange: (checked: boolean) => void;
  label: string;
  badge: string;
  description: string;
}) {
  return (
    <div className="flex items-start justify-between py-2">
      <div className="flex-1">
        <div className="flex items-center gap-2">
          <span className="text-sm text-[var(--claude-text)]">{label}</span>
          <span className="text-xs px-2 py-0.5 rounded-full bg-[var(--claude-sand-light)] text-[var(--claude-text-muted)]">
            {badge}
          </span>
        </div>
        <p className="text-xs text-[var(--claude-text-muted)]">{description}</p>
      </div>
      <button
        role="switch"
        aria-checked={checked}
        onClick={() => onChange(!checked)}
        className={`relative w-9 h-5 rounded-full transition-colors flex-shrink-0 ml-3 ${
          checked ? 'bg-[var(--claude-terracotta)]' : 'bg-[var(--claude-sand)]'
        }`}
      >
        <span
          className={`absolute top-0.5 w-4 h-4 rounded-full bg-white shadow transition-transform ${
            checked ? 'left-[18px]' : 'left-0.5'
          }`}
        />
      </button>
    </div>
  );
}



==================================================
FILE: ./src/components/SettingsPanel.tsx
==================================================
'use client';

import React, { useState } from 'react';
import { X, Shield, Zap, Globe, Brain, Gauge, DollarSign, Moon, Sun, Terminal, Database, FileUp, Key, Eye, EyeOff, Check, LogOut, Github } from 'lucide-react';
import { Settings, ModelType, EffortLevel, WebSearchMode, MODEL_DISPLAY_NAMES } from '@/types';

interface SettingsPanelProps {
  isOpen: boolean;
  onClose: () => void;
  settings: Settings;
  onSettingsChange: (settings: Settings) => void;
  darkMode: boolean;
  onDarkModeChange: (dark: boolean) => void;
  anthropicKey?: string;
  githubToken?: string;
  githubUser?: string;
  onAnthropicKeyChange?: (key: string) => void;
  onGithubTokenChange?: (token: string) => void;
  onLogout?: () => void;
}

export default function SettingsPanel({
  isOpen,
  onClose,
  settings,
  onSettingsChange,
  darkMode,
  onDarkModeChange,
  anthropicKey = '',
  githubToken = '',
  githubUser = '',
  onAnthropicKeyChange,
  onGithubTokenChange,
  onLogout,
}: SettingsPanelProps) {
  const [showAnthropicKey, setShowAnthropicKey] = useState(false);
  const [showGithubToken, setShowGithubToken] = useState(false);

  if (!isOpen) return null;

  const updateSetting = <K extends keyof Settings>(key: K, value: Settings[K]) => {
    onSettingsChange({ ...settings, [key]: value });
  };

  return (
    <div className="fixed inset-0 z-50 flex justify-end">
      {/* Overlay */}
      <div
        className="absolute inset-0 bg-black/40 backdrop-blur-sm"
        onClick={onClose}
      />

      {/* Panel */}
      <div className="relative w-full max-w-md h-full bg-[var(--claude-surface)] border-l border-[var(--claude-border)] flex flex-col animate-slide-in-right">
        {/* Header - flex-shrink-0 */}
        <div className="flex-shrink-0 flex items-center justify-between px-6 py-5 border-b border-[var(--claude-border)]">
          <h2 className="text-xl font-serif text-[var(--claude-text)]">Settings</h2>
          <button
            onClick={onClose}
            className="p-2 rounded-lg hover:bg-[var(--claude-sand-light)] text-[var(--claude-text-secondary)] transition-colors"
          >
            <X className="w-5 h-5" />
          </button>
        </div>

        {/* Body - flex-1 overflow-y-auto */}
        <div className="flex-1 overflow-y-auto p-6 space-y-8">
          {/* Deploy Mode */}
          <SettingSection
            icon={<Shield className="w-5 h-5" />}
            title="Deploy Mode"
            description="Choose how changes are pushed to GitHub"
          >
            <div className="grid grid-cols-2 gap-3">
              <ModeButton
                active={settings.deployMode === 'safe'}
                onClick={() => updateSetting('deployMode', 'safe')}
                label="Safe Mode"
                description="Creates PR for review"
                color="success"
              />
              <ModeButton
                active={settings.deployMode === 'direct'}
                onClick={() => updateSetting('deployMode', 'direct')}
                label="Direct Mode"
                description="Push to main"
                color="warning"
              />
            </div>
          </SettingSection>

          {/* Model */}
          <SettingSection
            icon={<Zap className="w-5 h-5" />}
            title="Model"
            description="Select the Claude model to use"
          >
            <div className="space-y-2">
              {(Object.entries(MODEL_DISPLAY_NAMES) as [ModelType, typeof MODEL_DISPLAY_NAMES[ModelType]][]).map(([modelId, info]) => (
                <button
                  key={modelId}
                  onClick={() => updateSetting('model', modelId)}
                  className={`w-full px-4 py-3 rounded-xl text-left transition-all ${
                    settings.model === modelId
                      ? 'bg-[var(--claude-terracotta)] text-white'
                      : 'bg-[var(--claude-surface-sunken)] text-[var(--claude-text)] hover:bg-[var(--claude-sand-light)]'
                  }`}
                >
                  <div className="flex items-center justify-between">
                    <span className="font-medium">{info.name}</span>
                    <span>{info.cost}</span>
                  </div>
                  <p className={`text-sm ${settings.model === modelId ? 'text-white/80' : 'text-[var(--claude-text-muted)]'}`}>
                    {info.description}
                  </p>
                </button>
              ))}
            </div>
          </SettingSection>

          {/* Effort Level */}
          <SettingSection
            icon={<Gauge className="w-5 h-5" />}
            title="Effort Level"
            description="Controls response depth and thoroughness"
          >
            <div className="grid grid-cols-3 gap-3">
              {(['low', 'medium', 'high'] as EffortLevel[]).map((level) => (
                <button
                  key={level}
                  onClick={() => updateSetting('effort', level)}
                  className={`
                    px-4 py-2.5 rounded-xl text-sm font-medium capitalize transition-all
                    ${settings.effort === level
                      ? 'bg-[var(--claude-terracotta)] text-white'
                      : 'bg-[var(--claude-surface-sunken)] text-[var(--claude-text-secondary)] hover:bg-[var(--claude-sand-light)]'
                    }
                  `}
                >
                  {level}
                </button>
              ))}
            </div>
          </SettingSection>

          {/* Web Search */}
          <SettingSection
            icon={<Globe className="w-5 h-5" />}
            title="Web Search"
            description="Enable searching the web for current information"
          >
            <div className="space-y-3">
              <div className="grid grid-cols-3 gap-2">
                {(['off', 'manual', 'auto'] as WebSearchMode[]).map((mode) => (
                  <button
                    key={mode}
                    onClick={() => {
                      updateSetting('webSearchMode', mode);
                      updateSetting('enableWebSearch', mode !== 'off');
                    }}
                    className={`px-3 py-2 rounded-xl text-sm font-medium capitalize transition-all ${
                      settings.webSearchMode === mode
                        ? 'bg-[var(--claude-terracotta)] text-white'
                        : 'bg-[var(--claude-surface-sunken)] text-[var(--claude-text-secondary)] hover:bg-[var(--claude-sand-light)]'
                    }`}
                  >
                    {mode}
                  </button>
                ))}
              </div>
              <p className="text-xs text-[var(--claude-text-muted)]">
                {settings.webSearchMode === 'off' && 'Web search disabled'}
                {settings.webSearchMode === 'manual' && 'Only searches when you ask'}
                {settings.webSearchMode === 'auto' && 'Claude decides when to search'}
              </p>
            </div>
          </SettingSection>

          {/* Extended Thinking */}
          <SettingSection
            icon={<Brain className="w-5 h-5" />}
            title="Extended Thinking"
            description="Allow Claude to think through complex problems"
          >
            <Toggle
              checked={settings.enableExtendedThinking}
              onChange={(checked) => updateSetting('enableExtendedThinking', checked)}
              label="Enable extended thinking"
            />
            {settings.enableExtendedThinking && (
              <div className="mt-4">
                <label className="text-sm text-[var(--claude-text-secondary)]">
                  Thinking budget: {settings.thinkingBudget.toLocaleString()} tokens
                </label>
                <input
                  type="range"
                  min={1024}
                  max={32000}
                  step={1024}
                  value={settings.thinkingBudget}
                  onChange={(e) => updateSetting('thinkingBudget', parseInt(e.target.value))}
                  className="w-full mt-2"
                />
              </div>
            )}
            {settings.enableExtendedThinking && (
              <Toggle
                checked={settings.enableInterleavedThinking}
                onChange={(checked) => updateSetting('enableInterleavedThinking', checked)}
                label="Interleaved thinking (think between tool calls)"
                className="mt-3"
              />
            )}
          </SettingSection>

          {/* Context Compaction */}
          <SettingSection
            icon={<Database className="w-5 h-5" />}
            title="Context Compaction"
            description="Auto-summarize old messages to save tokens"
          >
            <Toggle
              checked={settings.enableContextCompaction}
              onChange={(checked) => updateSetting('enableContextCompaction', checked)}
              label="Enable context compaction"
            />
            {settings.enableContextCompaction && (
              <p className="mt-2 text-xs text-[var(--claude-text-muted)]">
                Claude will automatically summarize older tool results to keep the context manageable.
              </p>
            )}
          </SettingSection>

          {/* Code Execution (Beta) */}
          <SettingSection
            icon={<Terminal className="w-5 h-5" />}
            title="Code Execution"
            description="Let Claude run Python code to verify fixes"
          >
            <Toggle
              checked={settings.enableCodeExecution}
              onChange={(checked) => updateSetting('enableCodeExecution', checked)}
              label="Enable code execution (beta)"
            />
            {settings.enableCodeExecution && (
              <p className="mt-2 text-xs text-[var(--claude-text-muted)]">
                50 free hours/day, then $0.05/hour. Claude can run Python in a sandbox.
              </p>
            )}
          </SettingSection>

          {/* Memory (Beta) */}
          <SettingSection
            icon={<Database className="w-5 h-5" />}
            title="Memory"
            description="Store context across conversations"
          >
            <Toggle
              checked={settings.enableMemory}
              onChange={(checked) => updateSetting('enableMemory', checked)}
              label="Enable memory (beta)"
            />
            {settings.enableMemory && (
              <p className="mt-2 text-xs text-[var(--claude-text-muted)]">
                Claude can save/recall info in /memories directory across sessions.
              </p>
            )}
          </SettingSection>

          {/* Files API (Beta) */}
          <SettingSection
            icon={<FileUp className="w-5 h-5" />}
            title="Files API"
            description="Upload files once, use across messages"
          >
            <Toggle
              checked={settings.enableFilesApi}
              onChange={(checked) => updateSetting('enableFilesApi', checked)}
              label="Enable Files API (beta)"
            />
            {settings.enableFilesApi && (
              <p className="mt-2 text-xs text-[var(--claude-text-muted)]">
                Uploaded files are stored and can be referenced across the entire conversation without re-uploading.
              </p>
            )}
          </SettingSection>

          {/* Token Budget */}
          <SettingSection
            icon={<DollarSign className="w-5 h-5" />}
            title="Cost Limits"
            description="Set spending limits to control costs"
          >
            <Toggle
              checked={settings.tokenBudget.enabled}
              onChange={(checked) => updateSetting('tokenBudget', { ...settings.tokenBudget, enabled: checked })}
              label="Enable cost limits"
            />
            {settings.tokenBudget.enabled && (
              <div className="mt-4 space-y-4">
                <div>
                  <label className="text-sm text-[var(--claude-text-secondary)]">
                    Per message: ${settings.tokenBudget.perMessage.toFixed(2)}
                  </label>
                  <input
                    type="range"
                    min={0.1}
                    max={5}
                    step={0.1}
                    value={settings.tokenBudget.perMessage}
                    onChange={(e) => updateSetting('tokenBudget', { ...settings.tokenBudget, perMessage: parseFloat(e.target.value) })}
                    className="w-full mt-2"
                  />
                </div>
                <div>
                  <label className="text-sm text-[var(--claude-text-secondary)]">
                    Per day: ${settings.tokenBudget.perDay.toFixed(2)}
                  </label>
                  <input
                    type="range"
                    min={1}
                    max={50}
                    step={1}
                    value={settings.tokenBudget.perDay}
                    onChange={(e) => updateSetting('tokenBudget', { ...settings.tokenBudget, perDay: parseFloat(e.target.value) })}
                    className="w-full mt-2"
                  />
                </div>
              </div>
            )}
          </SettingSection>

          {/* API Keys */}
          <SettingSection
            icon={<Key className="w-5 h-5" />}
            title="API Keys"
            description="Manage your API credentials"
          >
            <div className="space-y-4">
              {/* Anthropic API Key */}
              <div>
                <div className="flex items-center justify-between mb-2">
                  <label className="text-sm text-[var(--claude-text-secondary)]">
                    Anthropic API Key
                  </label>
                  <a
                    href="https://console.anthropic.com/settings/keys"
                    target="_blank"
                    rel="noopener noreferrer"
                    className="text-xs text-[var(--claude-terracotta)] hover:underline"
                  >
                    Get key 
                  </a>
                </div>
                <div className="relative">
                  <input
                    type={showAnthropicKey ? 'text' : 'password'}
                    value={anthropicKey}
                    onChange={(e) => onAnthropicKeyChange?.(e.target.value)}
                    placeholder="sk-ant-..."
                    className="w-full px-4 py-2.5 pr-10 rounded-xl bg-[var(--claude-surface-sunken)] border border-[var(--claude-border)] text-[var(--claude-text)] placeholder:text-[var(--claude-text-muted)] focus:outline-none focus:border-[var(--claude-terracotta)] text-sm"
                  />
                  <button
                    onClick={() => setShowAnthropicKey(!showAnthropicKey)}
                    className="absolute right-3 top-1/2 -translate-y-1/2 text-[var(--claude-text-muted)] hover:text-[var(--claude-text)]"
                  >
                    {showAnthropicKey ? <EyeOff className="w-4 h-4" /> : <Eye className="w-4 h-4" />}
                  </button>
                </div>
                {anthropicKey && (
                  <p className="text-xs text-[var(--claude-success)] mt-1 flex items-center gap-1">
                    <Check className="w-3 h-3" /> Valid
                  </p>
                )}
              </div>

              {/* GitHub Token */}
              <div>
                <div className="flex items-center justify-between mb-2">
                  <label className="text-sm text-[var(--claude-text-secondary)]">
                    GitHub Token
                  </label>
                  <a
                    href="https://github.com/settings/tokens"
                    target="_blank"
                    rel="noopener noreferrer"
                    className="text-xs text-[var(--claude-terracotta)] hover:underline"
                  >
                    Get token 
                  </a>
                </div>
                <div className="relative">
                  <input
                    type={showGithubToken ? 'text' : 'password'}
                    value={githubToken}
                    onChange={(e) => onGithubTokenChange?.(e.target.value)}
                    placeholder="ghp_... (optional)"
                    className="w-full px-4 py-2.5 pr-10 rounded-xl bg-[var(--claude-surface-sunken)] border border-[var(--claude-border)] text-[var(--claude-text)] placeholder:text-[var(--claude-text-muted)] focus:outline-none focus:border-[var(--claude-terracotta)] text-sm"
                  />
                  <button
                    onClick={() => setShowGithubToken(!showGithubToken)}
                    className="absolute right-3 top-1/2 -translate-y-1/2 text-[var(--claude-text-muted)] hover:text-[var(--claude-text)]"
                  >
                    {showGithubToken ? <EyeOff className="w-4 h-4" /> : <Eye className="w-4 h-4" />}
                  </button>
                </div>
                {githubToken && githubUser && (
                  <p className="text-xs text-[var(--claude-success)] mt-1 flex items-center gap-1">
                    <Check className="w-3 h-3" /> Connected as @{githubUser}
                  </p>
                )}
              </div>
            </div>
          </SettingSection>

          {/* Security */}
          <SettingSection
            icon={<Shield className="w-5 h-5" />}
            title="Security"
            description="Manage access and data"
          >
            <div className="space-y-3">
              <p className="text-sm text-[var(--claude-text-muted)]">
                Password is set via APP_PASSWORD environment variable.
              </p>
              <div className="flex gap-2">
                {onLogout && (
                  <button
                    onClick={onLogout}
                    className="flex items-center gap-2 px-4 py-2 rounded-xl bg-[var(--claude-surface-sunken)] text-[var(--claude-text-secondary)] hover:bg-[var(--claude-sand-light)] transition-colors text-sm"
                  >
                    <LogOut className="w-4 h-4" />
                    Log Out
                  </button>
                )}
                <button
                  onClick={() => {
                    if (confirm('Clear all stored data? This will remove your conversations and settings.')) {
                      localStorage.clear();
                      window.location.reload();
                    }
                  }}
                  className="flex items-center gap-2 px-4 py-2 rounded-xl bg-[var(--claude-error)]/10 text-[var(--claude-error)] hover:bg-[var(--claude-error)]/20 transition-colors text-sm"
                >
                  Clear All Data
                </button>
              </div>
            </div>
          </SettingSection>

          {/* Theme */}
          <SettingSection
            icon={darkMode ? <Moon className="w-5 h-5" /> : <Sun className="w-5 h-5" />}
            title="Theme"
            description="Choose light or dark mode"
          >
            <div className="grid grid-cols-2 gap-3">
              <button
                onClick={() => onDarkModeChange(false)}
                className={`
                  flex items-center justify-center gap-2 px-4 py-3 rounded-xl transition-all
                  ${!darkMode
                    ? 'bg-[var(--claude-terracotta)] text-white'
                    : 'bg-[var(--claude-surface-sunken)] text-[var(--claude-text-secondary)] hover:bg-[var(--claude-sand-light)]'
                  }
                `}
              >
                <Sun className="w-4 h-4" />
                Light
              </button>
              <button
                onClick={() => onDarkModeChange(true)}
                className={`
                  flex items-center justify-center gap-2 px-4 py-3 rounded-xl transition-all
                  ${darkMode
                    ? 'bg-[var(--claude-terracotta)] text-white'
                    : 'bg-[var(--claude-surface-sunken)] text-[var(--claude-text-secondary)] hover:bg-[var(--claude-sand-light)]'
                  }
                `}
              >
                <Moon className="w-4 h-4" />
                Dark
              </button>
            </div>
          </SettingSection>
        </div>

        {/* Footer - flex-shrink-0 */}
        <div className="flex-shrink-0 px-6 py-4 border-t border-[var(--claude-border)]">
          <button
            onClick={onClose}
            className="w-full px-4 py-3 rounded-xl bg-[var(--claude-terracotta)] text-white font-medium hover:bg-[var(--claude-terracotta-hover)] transition-colors"
          >
            Done
          </button>
        </div>
      </div>
    </div>
  );
}

// Helper components

function SettingSection({
  icon,
  title,
  description,
  children,
}: {
  icon: React.ReactNode;
  title: string;
  description: string;
  children: React.ReactNode;
}) {
  return (
    <div>
      <div className="flex items-center gap-3 mb-3">
        <div className="p-2 rounded-lg bg-[var(--claude-terracotta-subtle)] text-[var(--claude-terracotta)]">
          {icon}
        </div>
        <div>
          <h3 className="font-medium text-[var(--claude-text)]">{title}</h3>
          <p className="text-sm text-[var(--claude-text-muted)]">{description}</p>
        </div>
      </div>
      {children}
    </div>
  );
}

function Toggle({
  checked,
  onChange,
  label,
  className = '',
}: {
  checked: boolean;
  onChange: (checked: boolean) => void;
  label: string;
  className?: string;
}) {
  return (
    <label className={`flex items-center justify-between cursor-pointer ${className}`}>
      <span className="text-sm text-[var(--claude-text-secondary)]">{label}</span>
      <button
        role="switch"
        aria-checked={checked}
        onClick={() => onChange(!checked)}
        className={`
          relative w-11 h-6 rounded-full transition-colors
          ${checked ? 'bg-[var(--claude-terracotta)]' : 'bg-[var(--claude-sand)]'}
        `}
      >
        <span
          className={`
            absolute top-1 w-4 h-4 rounded-full bg-white shadow transition-transform
            ${checked ? 'left-6' : 'left-1'}
          `}
        />
      </button>
    </label>
  );
}

function ModeButton({
  active,
  onClick,
  label,
  description,
  color,
}: {
  active: boolean;
  onClick: () => void;
  label: string;
  description: string;
  color: 'success' | 'warning';
}) {
  const colorClasses = {
    success: active
      ? 'bg-[var(--claude-success)]/10 border-[var(--claude-success)] text-[var(--claude-success)]'
      : 'hover:bg-[var(--claude-success)]/5',
    warning: active
      ? 'bg-[var(--claude-warning)]/10 border-[var(--claude-warning)] text-[var(--claude-warning)]'
      : 'hover:bg-[var(--claude-warning)]/5',
  };

  return (
    <button
      onClick={onClick}
      className={`
        p-4 rounded-xl border text-left transition-all
        ${active ? colorClasses[color] : `border-[var(--claude-border)] ${colorClasses[color]}`}
      `}
    >
      <p className={`font-medium ${active ? '' : 'text-[var(--claude-text)]'}`}>{label}</p>
      <p className="text-xs mt-1 text-[var(--claude-text-muted)]">{description}</p>
    </button>
  );
}



==================================================
FILE: ./src/components/Sidebar.tsx
==================================================
'use client';

import React from 'react';
import { Plus, Search, MessageSquare, ChevronLeft, ChevronRight, Check, GitBranch, FileCode } from 'lucide-react';
import { Conversation, Session } from '@/types';

interface SidebarProps {
  isOpen: boolean;
  onToggle: () => void;
  conversations: Conversation[];
  currentConversationId: string | null;
  onNewChat: () => void;
  onSelectConversation: (id: string) => void;
  totalCost: number;
}

export default function Sidebar({
  isOpen,
  onToggle,
  conversations,
  currentConversationId,
  onNewChat,
  onSelectConversation,
  totalCost,
}: SidebarProps) {
  const [searchQuery, setSearchQuery] = React.useState('');

  const filteredConversations = conversations.filter(conv =>
    conv.title.toLowerCase().includes(searchQuery.toLowerCase())
  );

  // Convert conversations to session-like display
  const formatDate = (date: Date) => {
    const d = new Date(date);
    const now = new Date();
    const diff = now.getTime() - d.getTime();
    const days = Math.floor(diff / (1000 * 60 * 60 * 24));
    
    if (days === 0) return 'Today';
    if (days === 1) return 'Yesterday';
    if (days < 7) return d.toLocaleDateString('en-US', { weekday: 'short' });
    return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
  };

  // Collapsed state
  if (!isOpen) {
    return (
      <div className="w-12 h-full bg-[var(--claude-surface-sunken)] border-r border-[var(--claude-border)] flex flex-col items-center py-4">
        <button
          onClick={onToggle}
          className="p-2 rounded-lg hover:bg-[var(--claude-sand-light)] text-[var(--claude-text-secondary)] transition-colors"
          title="Expand sidebar"
        >
          <ChevronRight className="w-5 h-5" />
        </button>
        <button
          onClick={onNewChat}
          className="mt-4 p-2 rounded-lg bg-[var(--claude-terracotta)] text-white hover:bg-[var(--claude-terracotta-hover)] transition-colors"
          title="New chat"
        >
          <Plus className="w-5 h-5" />
        </button>
      </div>
    );
  }

  return (
    <div className="w-64 h-full bg-[var(--claude-surface-sunken)] border-r border-[var(--claude-border)] flex flex-col animate-slide-in-left">
      {/* Header */}
      <div className="flex items-center justify-between p-4 border-b border-[var(--claude-border)]">
        <span className="font-medium text-[var(--claude-text)]">Sessions</span>
        <button
          onClick={onToggle}
          className="p-1.5 rounded-lg hover:bg-[var(--claude-sand-light)] text-[var(--claude-text-secondary)] transition-colors"
        >
          <ChevronLeft className="w-4 h-4" />
        </button>
      </div>

      {/* New Chat Button */}
      <div className="p-3">
        <button
          onClick={onNewChat}
          className="w-full flex items-center justify-center gap-2 px-4 py-2.5 rounded-xl bg-[var(--claude-terracotta)] text-white font-medium hover:bg-[var(--claude-terracotta-hover)] transition-colors"
        >
          <Plus className="w-4 h-4" />
          New Chat
        </button>
      </div>

      {/* Search */}
      <div className="px-3 pb-3">
        <div className="relative">
          <Search className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-[var(--claude-text-muted)]" />
          <input
            type="text"
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            placeholder="Search sessions..."
            className="w-full pl-9 pr-3 py-2 rounded-lg bg-[var(--claude-surface)] border border-[var(--claude-border)] text-sm text-[var(--claude-text)] placeholder:text-[var(--claude-text-muted)] focus:outline-none focus:border-[var(--claude-terracotta)]"
          />
        </div>
      </div>

      {/* Conversations List */}
      <div className="flex-1 overflow-y-auto px-3">
        <div className="space-y-1">
          {filteredConversations.map((conv) => (
            <button
              key={conv.id}
              onClick={() => onSelectConversation(conv.id)}
              className={`
                w-full text-left p-3 rounded-xl transition-colors
                ${currentConversationId === conv.id
                  ? 'bg-[var(--claude-terracotta-subtle)] border border-[var(--claude-terracotta)]/20'
                  : 'hover:bg-[var(--claude-surface)] border border-transparent'
                }
              `}
            >
              <div className="flex items-start gap-2">
                {conv.isComplete ? (
                  <Check className="w-4 h-4 mt-0.5 text-[var(--claude-success)]" />
                ) : (
                  <MessageSquare className="w-4 h-4 mt-0.5 text-[var(--claude-text-muted)]" />
                )}
                <div className="flex-1 min-w-0">
                  <p className="text-sm font-medium text-[var(--claude-text)] truncate">
                    {conv.title || 'New conversation'}
                  </p>
                  <div className="flex items-center gap-2 mt-1 text-xs text-[var(--claude-text-muted)]">
                    {conv.repoName && (
                      <span className="truncate">{conv.repoName}</span>
                    )}
                    <span></span>
                    <span>{formatDate(conv.updatedAt)}</span>
                  </div>
                  {/* File changes summary */}
                  {conv.filesChanged && conv.filesChanged.length > 0 && (
                    <div className="flex items-center gap-2 mt-1.5 text-xs font-mono">
                      <FileCode className="w-3 h-3 text-[var(--claude-text-muted)]" />
                      <span className="text-[var(--claude-success)]">
                        +{conv.filesChanged.reduce((sum, f) => sum + (f.additions || 0), 0)}
                      </span>
                      <span className="text-[var(--claude-error)]">
                        -{conv.filesChanged.reduce((sum, f) => sum + (f.deletions || 0), 0)}
                      </span>
                    </div>
                  )}
                </div>
              </div>
            </button>
          ))}

          {filteredConversations.length === 0 && (
            <p className="text-sm text-[var(--claude-text-muted)] text-center py-8">
              {searchQuery ? 'No matching sessions' : 'No sessions yet'}
            </p>
          )}
        </div>
      </div>

      {/* Footer with totals */}
      <div className="p-4 border-t border-[var(--claude-border)]">
        <div className="flex items-center justify-between text-sm">
          <span className="text-[var(--claude-text-muted)]">Total sessions:</span>
          <span className="font-medium text-[var(--claude-text)]">{conversations.length}</span>
        </div>
        <div className="flex items-center justify-between text-sm mt-1">
          <span className="text-[var(--claude-text-muted)]">Total spent:</span>
          <span className="font-medium text-[var(--claude-text)]">${totalCost.toFixed(2)}</span>
        </div>
      </div>
    </div>
  );
}



==================================================
FILE: ./src/components/ThinkingBlock.tsx
==================================================
'use client';

import React, { useState } from 'react';
import { ChevronDown, ChevronRight, Brain } from 'lucide-react';

interface ThinkingBlockProps {
  content: string;
  isStreaming?: boolean;
}

export default function ThinkingBlock({ content, isStreaming = false }: ThinkingBlockProps) {
  const [isExpanded, setIsExpanded] = useState(false);

  if (!content) return null;

  return (
    <div className="my-3 rounded-xl border border-[var(--claude-border)] bg-[var(--claude-surface-sunken)] overflow-hidden">
      <button
        onClick={() => setIsExpanded(!isExpanded)}
        className="w-full flex items-center gap-3 px-4 py-3 text-left hover:bg-[var(--claude-sand-light)] transition-colors"
      >
        <Brain className="w-4 h-4 text-[var(--claude-terracotta)]" />
        <span className="text-sm font-medium text-[var(--claude-text-secondary)]">
          {isStreaming ? 'Thinking...' : 'View thinking'}
        </span>
        <div className="ml-auto">
          {isExpanded ? (
            <ChevronDown className="w-4 h-4 text-[var(--claude-text-muted)]" />
          ) : (
            <ChevronRight className="w-4 h-4 text-[var(--claude-text-muted)]" />
          )}
        </div>
        {isStreaming && (
          <div className="w-2 h-2 rounded-full bg-[var(--claude-terracotta)] animate-pulse" />
        )}
      </button>
      
      {isExpanded && (
        <div className="px-4 pb-4 pt-2 border-t border-[var(--claude-border)]">
          <pre className="text-sm font-mono text-[var(--claude-text-secondary)] whitespace-pre-wrap leading-relaxed">
            {content}
          </pre>
        </div>
      )}
    </div>
  );
}



==================================================
FILE: ./src/components/WelcomeScreen.tsx
==================================================
'use client';

import React from 'react';
import { GitBranch, Folder, Sparkles, MessageCircle, Code } from 'lucide-react';
import { Repository } from '@/types';

interface WelcomeScreenProps {
  repo?: Repository | null;
  branch?: string;
  onSuggestionClick?: (suggestion: string) => void;
}

export default function WelcomeScreen({ repo, branch, onSuggestionClick }: WelcomeScreenProps) {
  // Chat-only mode (no repo selected)
  if (!repo) {
    return (
      <div className="flex-1 flex flex-col items-center justify-center px-8 py-16 animate-fade-in">
        <div className="mb-8 text-center">
          <div className="inline-flex items-center justify-center w-16 h-16 mb-4 rounded-2xl bg-gradient-to-br from-[var(--claude-terracotta)] to-[#E89B7D] shadow-lg">
            <Sparkles className="w-8 h-8 text-white" />
          </div>
          <h1 className="text-4xl font-serif text-[var(--claude-text)] mb-2">
            What would you like to do?
          </h1>
        </div>

        <div className="flex flex-col gap-4 max-w-md w-full">
          {/* Chat option */}
          <div className="flex items-start gap-4 px-5 py-4 rounded-xl bg-[var(--claude-surface)] border border-[var(--claude-border)] shadow-sm">
            <div className="flex items-center justify-center w-10 h-10 rounded-lg bg-[var(--claude-terracotta-subtle)]">
              <MessageCircle className="w-5 h-5 text-[var(--claude-terracotta)]" />
            </div>
            <div>
              <p className="font-medium text-[var(--claude-text)]">Just chat with Claude</p>
              <p className="text-sm text-[var(--claude-text-muted)]">
                Ask questions, get help with code, brainstorm ideas
              </p>
            </div>
          </div>

          {/* Code editing option */}
          <div className="flex items-start gap-4 px-5 py-4 rounded-xl bg-[var(--claude-surface)] border border-[var(--claude-border)] shadow-sm">
            <div className="flex items-center justify-center w-10 h-10 rounded-lg bg-[var(--claude-terracotta-subtle)]">
              <Code className="w-5 h-5 text-[var(--claude-terracotta)]" />
            </div>
            <div>
              <p className="font-medium text-[var(--claude-text)]">Connect a repo to edit code</p>
              <p className="text-sm text-[var(--claude-text-muted)]">
                Select a repository from the dropdown above to enable code editing
              </p>
            </div>
          </div>
        </div>

        <p className="mt-8 text-sm text-[var(--claude-text-muted)]">
          Type a message below to start chatting
        </p>
      </div>
    );
  }

  // Repo connected mode
  return (
    <div className="flex-1 flex flex-col items-center justify-center px-8 py-16 animate-fade-in">
      {/* Logo/Title */}
      <div className="mb-8 text-center">
        <div className="inline-flex items-center justify-center w-16 h-16 mb-4 rounded-2xl bg-gradient-to-br from-[var(--claude-terracotta)] to-[#E89B7D] shadow-lg">
          <Sparkles className="w-8 h-8 text-white" />
        </div>
        <h1 className="text-4xl font-serif text-[var(--claude-text)] mb-2">
          Claude Coder
        </h1>
        <p className="text-lg text-[var(--claude-text-secondary)]">
          What are you working on?
        </p>
      </div>

      {/* Connected repo info */}
      <div className="mb-8 flex items-center gap-4 px-5 py-3 rounded-xl bg-[var(--claude-surface)] border border-[var(--claude-border)] shadow-sm">
        <Folder className="w-5 h-5 text-[var(--claude-terracotta)]" />
        <div>
          <p className="font-medium text-[var(--claude-text)]">{repo.fullName}</p>
          <div className="flex items-center gap-2 text-sm text-[var(--claude-text-secondary)]">
            <GitBranch className="w-3.5 h-3.5" />
            <span>{branch || repo.defaultBranch}</span>
          </div>
        </div>
      </div>

      {/* Quick tips */}
      <div className="max-w-md text-center text-sm text-[var(--claude-text-muted)]">
        <p className="mb-2"> Tip: Paste an error message and I&apos;ll find the file</p>
        <p>Just describe what you want to do - I&apos;ll figure out which files to look at</p>
      </div>
    </div>
  );
}



==================================================
FILE: ./src/lib/claude.ts
==================================================
// ============================================================================
// CLAUDE CLIENT - API Integration with all features
// Includes: Prompt caching, extended thinking, effort parameter, tools
// ============================================================================

import Anthropic from '@anthropic-ai/sdk';
import { 
  CostTracker, 
  TokenUsage, 
  MessageCost, 
  ModelType, 
  EffortLevel,
  Settings,
  ClaudeTool,
  MODEL_PRICING,
  Artifact,
  ArtifactType,
  Citation,
} from '@/types';

// ----------------------------------------------------------------------------
// Claude Client Class
// ----------------------------------------------------------------------------

export class ClaudeClient {
  private client: Anthropic;
  private model: ModelType;
  private costTracker: CostTracker;

  constructor(apiKey: string, model: ModelType = 'claude-sonnet-4-5-20250929') {
    this.client = new Anthropic({ apiKey });
    this.model = model;
    this.costTracker = {
      sessionCost: 0,
      dailyCost: 0,
      monthlyCost: 0,
      tokensUsed: { input: 0, output: 0, cacheRead: 0, cacheWrite: 0 },
    };
  }

  setModel(model: ModelType): void {
    this.model = model;
  }

  // --------------------------------------------------------------------------
  // Cost Calculation
  // --------------------------------------------------------------------------

  private calculateCost(usage: TokenUsage): MessageCost {
    const pricing = MODEL_PRICING[this.model];
    
    const inputCost = (usage.input || 0) * pricing.input / 1_000_000;
    const outputCost = (usage.output || 0) * pricing.output / 1_000_000;
    const cacheReadCost = (usage.cacheRead || 0) * pricing.cacheRead / 1_000_000;
    const cacheWriteCost = (usage.cacheWrite || 0) * pricing.cacheWrite / 1_000_000;
    
    const totalCost = inputCost + outputCost + cacheReadCost + cacheWriteCost;
    
    // Calculate savings from cache (compared to if all tokens were regular input)
    const withoutCache = ((usage.input || 0) + (usage.cacheRead || 0)) * pricing.input / 1_000_000;
    const withCache = inputCost + cacheReadCost;
    const savedPercent = withoutCache > 0 ? Math.round((1 - withCache / withoutCache) * 100) : 0;

    return {
      inputCost,
      outputCost,
      cacheReadCost,
      cacheWriteCost,
      totalCost,
      savedPercent: Math.max(0, savedPercent),
    };
  }

  private updateCostTracker(usage: TokenUsage): void {
    const cost = this.calculateCost(usage);
    this.costTracker.sessionCost += cost.totalCost;
    this.costTracker.dailyCost += cost.totalCost;
    this.costTracker.monthlyCost += cost.totalCost;

    this.costTracker.tokensUsed.input += usage.input || 0;
    this.costTracker.tokensUsed.output += usage.output || 0;
    this.costTracker.tokensUsed.cacheRead = (this.costTracker.tokensUsed.cacheRead || 0) + (usage.cacheRead || 0);
    this.costTracker.tokensUsed.cacheWrite = (this.costTracker.tokensUsed.cacheWrite || 0) + (usage.cacheWrite || 0);
  }

  getCostTracker(): CostTracker {
    return { ...this.costTracker };
  }

  resetSessionCost(): void {
    this.costTracker.sessionCost = 0;
    this.costTracker.tokensUsed = { input: 0, output: 0, cacheRead: 0, cacheWrite: 0 };
  }

  // --------------------------------------------------------------------------
  // Main Chat Function (Non-streaming)
  // --------------------------------------------------------------------------

  async chat(
    messages: Array<{ role: 'user' | 'assistant'; content: string }>,
    systemPrompt: string,
    codeContext: string,
    options: {
      tools?: ClaudeTool[];
      enableThinking?: boolean;
      thinkingBudget?: number;
      effort?: EffortLevel;
      enableCodeExecution?: boolean;
      enableMemory?: boolean;
      enableContextCompaction?: boolean;
      enableInterleavedThinking?: boolean;
    } = {}
  ): Promise<{
    content: string;
    toolCalls?: Array<{ id: string; name: string; input: Record<string, unknown> }>;
    usage: TokenUsage;
    cost: number;
    savedPercent: number;
    thinkingContent?: string;
    artifacts?: Artifact[];
    citations?: Citation[];
    codeExecutionResults?: Array<{ stdout: string; stderr: string; returnCode: number }>;
  }> {
    const { 
      tools, 
      enableThinking = false, 
      thinkingBudget = 10000,
      effort = 'medium',
      enableCodeExecution = false,
      enableMemory = false,
      enableContextCompaction = false,
      enableInterleavedThinking = false,
    } = options;

    // Map effort to max_tokens and thinking budget
    const effortConfig = {
      low: { maxTokens: 4000, thinkingMultiplier: 0.5 },
      medium: { maxTokens: 16000, thinkingMultiplier: 1.0 },
      high: { maxTokens: 32000, thinkingMultiplier: 2.0 },
    };
    const config = effortConfig[effort] || effortConfig.medium;
    const adjustedThinkingBudget = Math.round(thinkingBudget * config.thinkingMultiplier);

    // Build tools array with special tools
    const allTools: Array<ClaudeTool | { type: string; name: string }> = [...(tools || this.getDefaultTools())];
    
    if (enableCodeExecution) {
      allTools.push(this.getCodeExecutionTool());
    }
    
    if (enableMemory) {
      allTools.push(this.getMemoryTool());
    }

    // Build beta headers array
    const betas: string[] = [];
    if (enableCodeExecution) {
      betas.push('code-execution-2025-05-22');
    }
    if (enableMemory || enableContextCompaction) {
      betas.push('context-management-2025-06-27');
    }
    if (enableInterleavedThinking) {
      betas.push('interleaved-thinking-2025-05-14');
    }

    // Build request parameters
    const requestParams: Anthropic.MessageCreateParams = {
      model: this.model,
      max_tokens: config.maxTokens,
      system: [
        {
          type: 'text',
          text: systemPrompt,
        },
        {
          type: 'text',
          text: codeContext,
          // Enable prompt caching for code context (1-hour extended TTL)
          cache_control: { type: 'ephemeral' },
        },
      ],
      messages: messages.map(m => ({
        role: m.role,
        content: m.content,
      })),
      tools: allTools as Anthropic.MessageCreateParams['tools'],
    };

    // Add extended thinking if enabled
    if (enableThinking && (this.model.includes('opus') || this.model.includes('sonnet'))) {
      (requestParams as unknown as Record<string, unknown>).thinking = {
        type: 'enabled',
        budget_tokens: Math.max(1024, Math.min(adjustedThinkingBudget, 32000)),
      };
    }

    // Make API call with beta headers if needed
    let response: Anthropic.Message;
    if (betas.length > 0) {
      response = await this.client.beta.messages.create({
        ...requestParams,
        betas,
      } as Parameters<typeof this.client.beta.messages.create>[0]) as unknown as Anthropic.Message;
    } else {
      response = await this.client.messages.create(requestParams);
    }

    // Parse usage
    const usage: TokenUsage = {
      input: response.usage.input_tokens,
      output: response.usage.output_tokens,
      cacheRead: (response.usage as unknown as Record<string, number>).cache_read_input_tokens || 0,
      cacheWrite: (response.usage as unknown as Record<string, number>).cache_creation_input_tokens || 0,
    };

    this.updateCostTracker(usage);
    const costInfo = this.calculateCost(usage);

    // Extract content, tool calls, thinking, artifacts, and citations
    let content = '';
    let thinkingContent = '';
    const toolCalls: Array<{ id: string; name: string; input: Record<string, unknown> }> = [];
    const artifacts: Artifact[] = [];
    const citations: Citation[] = [];

    for (const block of response.content) {
      if (block.type === 'text') {
        content += block.text;
        // Parse artifacts from content
        const parsedArtifacts = this.parseArtifacts(block.text);
        artifacts.push(...parsedArtifacts);
        // Parse citations if present (from web search tool results)
        const blockAny = block as unknown as { text: string; citations?: Array<{ url?: string; cited_text?: string; start_char_index?: number; end_char_index?: number; title?: string }> };
        if (blockAny.citations && Array.isArray(blockAny.citations)) {
          for (const cite of blockAny.citations) {
            if (cite.url) {
              citations.push({
                url: cite.url,
                title: cite.title,
                snippet: cite.cited_text,
                startIndex: cite.start_char_index || 0,
                endIndex: cite.end_char_index || 0,
              });
            }
          }
        }
      } else if (block.type === 'tool_use') {
        toolCalls.push({
          id: block.id,
          name: block.name,
          input: block.input as Record<string, unknown>,
        });
      } else if (block.type === 'thinking') {
        thinkingContent += (block as { type: 'thinking'; thinking: string }).thinking;
      }
    }

    return {
      content,
      toolCalls: toolCalls.length > 0 ? toolCalls : undefined,
      usage,
      cost: costInfo.totalCost,
      savedPercent: costInfo.savedPercent,
      thinkingContent: thinkingContent || undefined,
      artifacts: artifacts.length > 0 ? artifacts : undefined,
      citations: citations.length > 0 ? citations : undefined,
    };
  }

  // --------------------------------------------------------------------------
  // Streaming Chat
  // --------------------------------------------------------------------------

  async *streamChat(
    messages: Array<{ role: 'user' | 'assistant'; content: string }>,
    systemPrompt: string,
    codeContext: string,
    options: {
      tools?: ClaudeTool[];
      enableThinking?: boolean;
      thinkingBudget?: number;
      effort?: EffortLevel;
      enableContextCompaction?: boolean;
      enableInterleavedThinking?: boolean;
    } = {}
  ): AsyncGenerator<{
    type: 'text' | 'thinking' | 'tool_use' | 'citation' | 'done';
    content?: string;
    toolCall?: { id: string; name: string; input: Record<string, unknown> };
    citation?: Citation;
    usage?: TokenUsage;
    cost?: number;
    savedPercent?: number;
  }> {
    const { 
      tools, 
      enableThinking = false, 
      thinkingBudget = 10000,
      effort = 'medium',
      enableContextCompaction = false,
      enableInterleavedThinking = false,
    } = options;

    // Map effort to max_tokens and thinking budget
    const effortConfig = {
      low: { maxTokens: 4000, thinkingMultiplier: 0.5 },
      medium: { maxTokens: 16000, thinkingMultiplier: 1.0 },
      high: { maxTokens: 32000, thinkingMultiplier: 2.0 },
    };
    const config = effortConfig[effort] || effortConfig.medium;
    const adjustedThinkingBudget = Math.round(thinkingBudget * config.thinkingMultiplier);

    // Build beta headers
    const betas: string[] = [];
    if (enableContextCompaction) {
      betas.push('context-management-2025-06-27');
    }
    if (enableInterleavedThinking) {
      betas.push('interleaved-thinking-2025-05-14');
    }

    const requestParams: Anthropic.MessageCreateParams = {
      model: this.model,
      max_tokens: config.maxTokens,
      stream: true,
      system: [
        {
          type: 'text',
          text: systemPrompt,
        },
        {
          type: 'text',
          text: codeContext,
          cache_control: { type: 'ephemeral' },
        },
      ],
      messages: messages.map(m => ({
        role: m.role,
        content: m.content,
      })),
      tools: tools || this.getDefaultTools(),
    };

    if (enableThinking && (this.model.includes('opus') || this.model.includes('sonnet'))) {
      (requestParams as unknown as Record<string, unknown>).thinking = {
        type: 'enabled',
        budget_tokens: Math.max(1024, Math.min(adjustedThinkingBudget, 32000)),
      };
    }

    // Use beta streaming if we have beta headers
    let stream;
    if (betas.length > 0) {
      stream = await this.client.beta.messages.stream({
        ...requestParams,
        betas,
      } as Parameters<typeof this.client.beta.messages.stream>[0]);
    } else {
      stream = await this.client.messages.stream(requestParams);
    }

    let currentToolCall: { id: string; name: string; input: string } | null = null;

    for await (const event of stream) {
      if (event.type === 'content_block_delta') {
        const delta = event.delta;
        
        if ('text' in delta) {
          yield { type: 'text', content: delta.text };
        } else if ('thinking' in delta) {
          yield { type: 'thinking', content: (delta as { thinking: string }).thinking };
        } else if ('partial_json' in delta && currentToolCall) {
          currentToolCall.input += (delta as { partial_json: string }).partial_json;
        }
      } else if (event.type === 'content_block_start') {
        if (event.content_block.type === 'tool_use') {
          currentToolCall = {
            id: event.content_block.id,
            name: event.content_block.name,
            input: '',
          };
        }
      } else if (event.type === 'content_block_stop') {
        if (currentToolCall) {
          try {
            const parsedInput = JSON.parse(currentToolCall.input || '{}');
            yield {
              type: 'tool_use',
              toolCall: {
                id: currentToolCall.id,
                name: currentToolCall.name,
                input: parsedInput,
              },
            };
          } catch {
            // Invalid JSON, skip
          }
          currentToolCall = null;
        }
      } else if (event.type === 'message_stop') {
        // Get final usage from the accumulated message
        const finalMessage = await stream.finalMessage();
        const usage: TokenUsage = {
          input: finalMessage.usage.input_tokens,
          output: finalMessage.usage.output_tokens,
          cacheRead: (finalMessage.usage as unknown as Record<string, number>).cache_read_input_tokens || 0,
          cacheWrite: (finalMessage.usage as unknown as Record<string, number>).cache_creation_input_tokens || 0,
        };

        this.updateCostTracker(usage);
        const costInfo = this.calculateCost(usage);

        yield {
          type: 'done',
          usage,
          cost: costInfo.totalCost,
          savedPercent: costInfo.savedPercent,
        };
      }
    }
  }

  // --------------------------------------------------------------------------
  // Default Tools
  // --------------------------------------------------------------------------

    getDefaultTools(): ClaudeTool[] {
    return [
      {
        name: 'read_file',
        description: 'Read the contents of a file from the repository',
        input_schema: {
          type: 'object',
          properties: {
            path: {
              type: 'string',
              description: 'The path to the file relative to repo root',
            },
          },
          required: ['path'],
        },
      },
      {
        name: 'str_replace',
        description: 'Replace a unique string in a file with another string. The old_str must appear exactly once in the file.',
        input_schema: {
          type: 'object',
          properties: {
            path: {
              type: 'string',
              description: 'The path to the file to edit',
            },
            old_str: {
              type: 'string',
              description: 'The exact string to find and replace (must be unique in the file)',
            },
            new_str: {
              type: 'string',
              description: 'The string to replace it with',
            },
          },
          required: ['path', 'old_str', 'new_str'],
        },
      },
      {
        name: 'create_file',
        description: 'Create a new file with the given content',
        input_schema: {
          type: 'object',
          properties: {
            path: {
              type: 'string',
              description: 'The path where the file should be created',
            },
            content: {
              type: 'string',
              description: 'The content of the new file',
            },
          },
          required: ['path', 'content'],
        },
      },
      {
        name: 'search_files',
        description: 'Search for files in the repository that match a query',
        input_schema: {
          type: 'object',
          properties: {
            query: {
              type: 'string',
              description: 'The search term to look for in file names or content',
            },
          },
          required: ['query'],
        },
      },
      {
        name: 'grep_search',
        description: 'Search inside file contents for a specific term. Returns matching lines with file paths and line numbers.',
        input_schema: {
          type: 'object',
          properties: {
            query: {
              type: 'string',
              description: 'The term to search for inside files',
            },
            file_extensions: {
              type: 'string',
              description: 'Optional comma-separated list of file extensions to search (e.g., "ts,tsx,js")',
            },
          },
          required: ['query'],
        },
      },
    ];
  }

  // --------------------------------------------------------------------------
  // Code Execution Tool (Beta)
  // --------------------------------------------------------------------------

  getCodeExecutionTool(): { type: string; name: string } {
    return {
      type: 'code_execution_20250522',
      name: 'code_execution',
    };
  }

  // --------------------------------------------------------------------------
  // Memory Tool (Beta) 
  // --------------------------------------------------------------------------

  getMemoryTool(): { type: string; name: string } {
    return {
      type: 'memory_20250818',
      name: 'memory',
    };
  }

  // --------------------------------------------------------------------------
  // Web Search Tool
  // --------------------------------------------------------------------------

  getWebSearchTool(): ClaudeTool {
    return {
      name: 'web_search',
      description: `Search the web for current, real-time information.

ALWAYS USE when the query involves:
- Current events, news, recent happenings
- "Latest", "newest", "current", "today", "2024", "2025"
- Prices, stock values, exchange rates
- Version numbers, release dates, changelogs
- Documentation for libraries/frameworks (may have updated)
- Error messages you don't recognize
- People's current roles/positions
- Availability, schedules, hours of operation
- Laws, regulations, policies (may have changed)
- Product comparisons, reviews, recommendations

NEVER USE when:
- User asks about their own code/repository
- Basic programming concepts
- Math calculations
- Historical facts that won't change
- Debugging user's specific code
- Explaining code the user provided
- Creative writing, brainstorming
- General coding patterns/best practices you already know

ASK YOURSELF: "Could this information have changed since my training?"
- If YES  search
- If NO  don't search`,
      input_schema: {
        type: 'object',
        properties: {
          query: {
            type: 'string',
            description: 'The search query',
          },
        },
        required: ['query'],
      },
    };
  }

  // --------------------------------------------------------------------------
  // Web Fetch Tool - Get full page content
  // --------------------------------------------------------------------------

  getWebFetchTool(): ClaudeTool {
    return {
      name: 'web_fetch',
      description: `Fetch the full content of a web page by URL.

USE when:
- You found a promising URL from web_search and need more details
- User provides a specific URL to read
- Documentation page needs complete reading
- Article or blog post requires full context

DO NOT USE for:
- Random URLs without reason
- Sites requiring authentication
- Very large pages (will be truncated)`,
      input_schema: {
        type: 'object',
        properties: {
          url: {
            type: 'string',
            description: 'The full URL to fetch (must include https://)',
          },
        },
        required: ['url'],
      },
    };
  }

  // --------------------------------------------------------------------------
  // Parse Artifacts from Response
  // --------------------------------------------------------------------------

  private parseArtifacts(content: string): Artifact[] {
    const artifacts: Artifact[] = [];
    
    // Match code blocks with language specifier
    const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
    let match;
    let artifactIndex = 0;

    while ((match = codeBlockRegex.exec(content)) !== null) {
      const language = match[1]?.toLowerCase() || 'text';
      const code = match[2];

      // Determine artifact type based on language
      let type: ArtifactType = 'code';
      if (language === 'html') type = 'html';
      else if (language === 'svg') type = 'svg';
      else if (language === 'mermaid') type = 'mermaid';
      else if (['jsx', 'tsx', 'react'].includes(language)) type = 'react';
      else if (['md', 'markdown'].includes(language)) type = 'markdown';

      artifacts.push({
        id: `artifact-${artifactIndex++}`,
        name: `Code ${artifactIndex}`,
        type,
        content: code,
        language,
      });
    }

    return artifacts;
  }
}

// ----------------------------------------------------------------------------
// System Prompt (Minimal - Let Claude be Claude)
// ----------------------------------------------------------------------------

export function getSystemPrompt(
  owner: string,
  repo: string,
  branch: string,
  enableWebSearch: boolean = false
): string {
  const tools = ['read_file', 'search_files', 'str_replace', 'create_file', 'grep_search'];
  if (enableWebSearch) tools.push('web_search');

  return `You are Claude, an AI assistant helping with coding.
You have access to the following repository:
- Owner: ${owner}
- Repo: ${repo}
- Branch: ${branch}

Available tools: ${tools.join(', ')}

When making edits:
1. Use str_replace for small changes (preferred - more efficient)
2. The old_str must be UNIQUE and EXACT
3. Use create_file only for new files
4. Always explain what you're doing

If a str_replace fails, try using more context around the string to make it unique.`;
}

// ----------------------------------------------------------------------------
// Generate Code Context for Prompt
// ----------------------------------------------------------------------------

export function generateCodeContext(
  fileTree: string,
  files: Array<{ path: string; content: string }>
): string {
  let context = `## Repository Structure\n\`\`\`\n${fileTree}\n\`\`\`\n\n`;
  context += `## Loaded Files\n\n`;

  for (const file of files) {
    const ext = file.path.split('.').pop() || '';
    context += `### ${file.path}\n\`\`\`${ext}\n${file.content}\n\`\`\`\n\n`;
  }

  context += `\nIf you need to see other files, use the read_file tool.\n`;

  return context;
}

// ----------------------------------------------------------------------------
// Extract Keywords from User Message (for Smart File Loading)
// ----------------------------------------------------------------------------

export function extractKeywords(message: string): string[] {
  // Remove common words and extract potential file/function names
  const commonWords = new Set([
    'the', 'a', 'an', 'is', 'are', 'was', 'were', 'be', 'been', 'being',
    'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could',
    'should', 'may', 'might', 'must', 'can', 'this', 'that', 'these',
    'those', 'i', 'you', 'he', 'she', 'it', 'we', 'they', 'what', 'which',
    'who', 'when', 'where', 'why', 'how', 'all', 'each', 'every', 'both',
    'few', 'more', 'most', 'other', 'some', 'such', 'no', 'not', 'only',
    'own', 'same', 'so', 'than', 'too', 'very', 'just', 'but', 'and',
    'or', 'if', 'because', 'as', 'until', 'while', 'of', 'at', 'by',
    'for', 'with', 'about', 'against', 'between', 'into', 'through',
    'during', 'before', 'after', 'above', 'below', 'to', 'from', 'up',
    'down', 'in', 'out', 'on', 'off', 'over', 'under', 'again', 'further',
    'then', 'once', 'here', 'there', 'all', 'any', 'both', 'each',
    'fix', 'add', 'create', 'update', 'change', 'modify', 'edit',
    'help', 'please', 'want', 'need', 'make', 'get', 'put', 'new',
    'file', 'code', 'function', 'component', 'error', 'bug', 'issue',
  ]);

  // Extract words that look like identifiers (camelCase, PascalCase, snake_case, filenames)
  const words = message.match(/[a-zA-Z_][a-zA-Z0-9_]*(?:\.[a-zA-Z]+)?/g) || [];
  
  return words
    .filter(word => {
      const lower = word.toLowerCase();
      // Keep if it's not a common word and has some length
      return !commonWords.has(lower) && word.length > 2;
    })
    .slice(0, 10); // Limit to 10 keywords
}



==================================================
FILE: ./src/lib/github.ts
==================================================
// ============================================================================
// GITHUB CLIENT - Smart File Loading & Operations
// From old version with upgrades: grep search, import tracing
// ============================================================================

import { Octokit } from 'octokit';
import { RepoFile, RepoTree, Branch, Repository, PullRequest, FileChange } from '@/types';

export class GitHubClient {
  private octokit: Octokit;
  private owner: string;
  private repo: string;
  private fileTreeCache: Map<string, RepoTree[]> = new Map();

  constructor(token: string, owner: string, repo: string) {
    this.octokit = new Octokit({ auth: token });
    this.owner = owner;
    this.repo = repo;
  }

  // --------------------------------------------------------------------------
  // Repository Info
  // --------------------------------------------------------------------------

  async getRepository(): Promise<Repository> {
    const { data } = await this.octokit.rest.repos.get({
      owner: this.owner,
      repo: this.repo,
    });

    return {
      owner: data.owner.login,
      name: data.name,
      fullName: data.full_name,
      defaultBranch: data.default_branch,
      isPrivate: data.private,
    };
  }

  // --------------------------------------------------------------------------
  // File Tree (with Session Cache)
  // --------------------------------------------------------------------------

  async getFileTree(branch: string = 'main', useCache: boolean = true): Promise<RepoTree[]> {
    const cacheKey = `${this.owner}/${this.repo}/${branch}`;
    
    // Return cached tree if available
    if (useCache && this.fileTreeCache.has(cacheKey)) {
      return this.fileTreeCache.get(cacheKey)!;
    }

    const sha = await this.getBranchSHA(branch);
    
    const { data } = await this.octokit.rest.git.getTree({
      owner: this.owner,
      repo: this.repo,
      tree_sha: sha,
      recursive: 'true',
    });

    const tree = this.buildTree(data.tree);
    
    // Cache the tree for this session
    this.fileTreeCache.set(cacheKey, tree);
    
    return tree;
  }

  clearTreeCache(): void {
    this.fileTreeCache.clear();
  }

  private async getBranchSHA(branch: string): Promise<string> {
    const { data } = await this.octokit.rest.repos.getBranch({
      owner: this.owner,
      repo: this.repo,
      branch,
    });
    return data.commit.sha;
  }

  private buildTree(flatTree: Array<{ path: string; type: string }>): RepoTree[] {
    const tree: RepoTree[] = [];
    const pathMap = new Map<string, RepoTree>();

    flatTree.sort((a, b) => a.path.localeCompare(b.path));

    for (const item of flatTree) {
      // Skip common non-essential directories
      if (this.shouldSkipPath(item.path)) continue;

      const node: RepoTree = {
        path: item.path,
        type: item.type === 'tree' ? 'dir' : 'file',
        children: item.type === 'tree' ? [] : undefined,
      };
      pathMap.set(item.path, node);

      const parentPath = item.path.split('/').slice(0, -1).join('/');
      if (parentPath && pathMap.has(parentPath)) {
        pathMap.get(parentPath)!.children!.push(node);
      } else {
        tree.push(node);
      }
    }

    return tree;
  }

  private shouldSkipPath(path: string): boolean {
    const skipPatterns = [
      'node_modules',
      '.git',
      '.next',
      'dist',
      'build',
      '.cache',
      'coverage',
      '__pycache__',
      '.venv',
      'venv',
    ];
    return skipPatterns.some(pattern => path.includes(pattern));
  }

  // --------------------------------------------------------------------------
  // File Content
  // --------------------------------------------------------------------------

  async getFileContent(path: string, branch: string = 'main'): Promise<RepoFile> {
    const { data } = await this.octokit.rest.repos.getContent({
      owner: this.owner,
      repo: this.repo,
      path,
      ref: branch,
    });

    if (Array.isArray(data) || data.type !== 'file') {
      throw new Error(`Path ${path} is not a file`);
    }

    const content = Buffer.from(data.content, 'base64').toString('utf-8');
    return { path, content, sha: data.sha };
  }

  async getFiles(paths: string[], branch: string = 'main'): Promise<RepoFile[]> {
    const files = await Promise.all(
      paths.map(path => this.getFileContent(path, branch).catch(() => null))
    );
    return files.filter((f): f is RepoFile => f !== null);
  }

  // --------------------------------------------------------------------------
  // Smart File Loading with Import Tracing
  // --------------------------------------------------------------------------

  async getFilesWithImports(
    entryPaths: string[],
    branch: string = 'main',
    maxDepth: number = 2
  ): Promise<RepoFile[]> {
    const loaded = new Set<string>();
    const files: RepoFile[] = [];

    const loadFile = async (path: string, depth: number): Promise<void> => {
      const possiblePaths = [
        path,
        `${path}.ts`,
        `${path}.tsx`,
        `${path}.js`,
        `${path}.jsx`,
        `${path}/index.ts`,
        `${path}/index.tsx`,
        `${path}/index.js`,
      ];

      for (const p of possiblePaths) {
        if (loaded.has(p)) return;

        try {
          const file = await this.getFileContent(p, branch);
          loaded.add(p);
          files.push(file);

          // Parse and follow imports if not at max depth
          if (depth < maxDepth) {
            const imports = this.parseImports(file.content, p);
            await Promise.all(imports.map(imp => loadFile(imp, depth + 1)));
          }
          return;
        } catch {
          // File doesn't exist with this extension, try next
        }
      }
    };

    await Promise.all(entryPaths.map(p => loadFile(p, 0)));
    return files;
  }

  private parseImports(content: string, currentPath: string): string[] {
    const imports: string[] = [];
    const importRegex = /import\s+.*\s+from\s+['"]([^'"]+)['"]/g;
    const requireRegex = /require\s*\(['"]([^'"]+)['"]\)/g;

    let match;
    while ((match = importRegex.exec(content)) !== null) {
      imports.push(this.resolveImportPath(match[1], currentPath));
    }
    while ((match = requireRegex.exec(content)) !== null) {
      imports.push(this.resolveImportPath(match[1], currentPath));
    }

    // Filter out node_modules imports and @/ aliases
    return imports.filter(i => 
      (i.startsWith('./') || i.startsWith('../')) && 
      !i.includes('node_modules')
    );
  }

  private resolveImportPath(importPath: string, currentPath: string): string {
    if (importPath.startsWith('./') || importPath.startsWith('../')) {
      const currentDir = currentPath.split('/').slice(0, -1).join('/');
      const parts = [...currentDir.split('/'), ...importPath.split('/')];
      const resolved: string[] = [];

      for (const part of parts) {
        if (part === '..') resolved.pop();
        else if (part !== '.' && part !== '') resolved.push(part);
      }

      return resolved.join('/');
    }
    return importPath;
  }

  // --------------------------------------------------------------------------
  // Grep Search - Search INSIDE file contents
  // --------------------------------------------------------------------------

  async grepSearch(
    query: string,
    branch: string = 'main',
    options: { maxResults?: number; fileExtensions?: string[] } = {}
  ): Promise<Array<{ path: string; line: number; content: string }>> {
    const { maxResults = 50, fileExtensions } = options;
    const results: Array<{ path: string; line: number; content: string }> = [];

    try {
      // Use GitHub's code search API
      const searchQuery = fileExtensions
        ? `${query} repo:${this.owner}/${this.repo} extension:${fileExtensions.join(',')}`
        : `${query} repo:${this.owner}/${this.repo}`;

      const { data } = await this.octokit.rest.search.code({
        q: searchQuery,
        per_page: Math.min(maxResults, 100),
      });

      // Get file contents and find exact line matches
      for (const item of data.items.slice(0, maxResults)) {
        try {
          const file = await this.getFileContent(item.path, branch);
          const lines = file.content.split('\n');
          
          lines.forEach((line, index) => {
            if (line.toLowerCase().includes(query.toLowerCase())) {
              results.push({
                path: item.path,
                line: index + 1,
                content: line.trim(),
              });
            }
          });
        } catch {
          // Skip files that can't be read
        }
      }
    } catch (error) {
      console.error('Grep search error:', error);
    }

    return results.slice(0, maxResults);
  }

  // --------------------------------------------------------------------------
  // File Search (by filename)
  // --------------------------------------------------------------------------

  async searchFiles(query: string): Promise<string[]> {
    const { data } = await this.octokit.rest.search.code({
      q: `${query} repo:${this.owner}/${this.repo}`,
      per_page: 20,
    });

    return data.items.map(item => item.path);
  }

  // --------------------------------------------------------------------------
  // Branch Operations
  // --------------------------------------------------------------------------

  async listBranches(): Promise<Branch[]> {
    const { data } = await this.octokit.rest.repos.listBranches({
      owner: this.owner,
      repo: this.repo,
    });

    const { data: repoData } = await this.octokit.rest.repos.get({
      owner: this.owner,
      repo: this.repo,
    });

    return data.map(b => ({
      name: b.name,
      sha: b.commit.sha,
      isDefault: b.name === repoData.default_branch,
    }));
  }

  async createBranch(branchName: string, fromBranch: string = 'main'): Promise<Branch> {
    const { data: refData } = await this.octokit.rest.git.getRef({
      owner: this.owner,
      repo: this.repo,
      ref: `heads/${fromBranch}`,
    });

    await this.octokit.rest.git.createRef({
      owner: this.owner,
      repo: this.repo,
      ref: `refs/heads/${branchName}`,
      sha: refData.object.sha,
    });

    return {
      name: branchName,
      sha: refData.object.sha,
      isDefault: false,
    };
  }

  async deleteBranch(branch: string): Promise<void> {
    await this.octokit.rest.git.deleteRef({
      owner: this.owner,
      repo: this.repo,
      ref: `heads/${branch}`,
    });
  }

  // --------------------------------------------------------------------------
  // File Operations
  // --------------------------------------------------------------------------

  async updateFile(
    path: string,
    content: string,
    message: string,
    branch: string,
    sha?: string
  ): Promise<void> {
    await this.octokit.rest.repos.createOrUpdateFileContents({
      owner: this.owner,
      repo: this.repo,
      path,
      message,
      content: Buffer.from(content).toString('base64'),
      branch,
      sha,
    });
  }

  async applyStrReplace(
    path: string,
    oldStr: string,
    newStr: string,
    branch: string
  ): Promise<{ success: boolean; error?: string; additions?: number; deletions?: number }> {
    try {
      const file = await this.getFileContent(path, branch);

      if (!file.content.includes(oldStr)) {
        return {
          success: false,
          error: `String not found in ${path}. Make sure the string is unique and exact.`,
        };
      }

      const occurrences = file.content.split(oldStr).length - 1;
      if (occurrences > 1) {
        return {
          success: false,
          error: `String found ${occurrences} times in ${path}. It must be unique for safe replacement.`,
        };
      }

      const newContent = file.content.replace(oldStr, newStr);
      await this.updateFile(path, newContent, `Edit ${path}`, branch, file.sha);

      // Calculate line changes
      const oldLines = oldStr.split('\n').length;
      const newLines = newStr.split('\n').length;

      return {
        success: true,
        additions: Math.max(0, newLines - oldLines) + 1,
        deletions: Math.max(0, oldLines - newLines) + 1,
      };
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      return { success: false, error: errorMessage };
    }
  }

  async createFile(
    path: string,
    content: string,
    branch: string
  ): Promise<{ success: boolean; error?: string; additions?: number }> {
    try {
      await this.octokit.rest.repos.createOrUpdateFileContents({
        owner: this.owner,
        repo: this.repo,
        path,
        message: `Create ${path}`,
        content: Buffer.from(content).toString('base64'),
        branch,
      });

      return {
        success: true,
        additions: content.split('\n').length,
      };
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      return { success: false, error: errorMessage };
    }
  }

  // --------------------------------------------------------------------------
  // Pull Request Operations
  // --------------------------------------------------------------------------

  async createPullRequest(
    title: string,
    body: string,
    head: string,
    base: string = 'main'
  ): Promise<PullRequest> {
    const { data } = await this.octokit.rest.pulls.create({
      owner: this.owner,
      repo: this.repo,
      title,
      body,
      head,
      base,
    });

    return {
      number: data.number,
      url: data.html_url,
      title: data.title,
      state: data.state as 'open' | 'closed' | 'merged',
      branch: head,
    };
  }

  async getPullRequest(prNumber: number): Promise<PullRequest> {
    const { data } = await this.octokit.rest.pulls.get({
      owner: this.owner,
      repo: this.repo,
      pull_number: prNumber,
    });

    return {
      number: data.number,
      url: data.html_url,
      title: data.title,
      state: data.merged ? 'merged' : (data.state as 'open' | 'closed'),
      branch: data.head.ref,
    };
  }

  // --------------------------------------------------------------------------
  // Recent Commits (for Sessions view)
  // --------------------------------------------------------------------------

  async getRecentCommits(branch: string = 'main', count: number = 10): Promise<Array<{
    sha: string;
    message: string;
    date: Date;
    author: string;
    filesChanged: number;
  }>> {
    const { data } = await this.octokit.rest.repos.listCommits({
      owner: this.owner,
      repo: this.repo,
      sha: branch,
      per_page: count,
    });

    return data.map(commit => ({
      sha: commit.sha,
      message: commit.commit.message,
      date: new Date(commit.commit.author?.date || Date.now()),
      author: commit.commit.author?.name || 'Unknown',
      filesChanged: 0, // Would need additional API call per commit
    }));
  }
}

// --------------------------------------------------------------------------
// Utility Functions
// --------------------------------------------------------------------------

export function formatFileTree(tree: RepoTree[], indent: string = ''): string {
  let result = '';
  for (const node of tree) {
    const icon = node.type === 'dir' ? '' : '';
    const name = node.path.split('/').pop();
    result += `${indent}${icon} ${name}\n`;
    if (node.children) {
      result += formatFileTree(node.children, indent + '  ');
    }
  }
  return result;
}

export function formatFilesForContext(files: RepoFile[]): string {
  return files.map(f => `
### ${f.path}
\`\`\`${getFileExtension(f.path)}
${f.content}
\`\`\`
`).join('\n');
}

function getFileExtension(path: string): string {
  const ext = path.split('.').pop()?.toLowerCase() || '';
  const langMap: Record<string, string> = {
    ts: 'typescript',
    tsx: 'tsx',
    js: 'javascript',
    jsx: 'jsx',
    py: 'python',
    json: 'json',
    css: 'css',
    html: 'html',
    md: 'markdown',
    yaml: 'yaml',
    yml: 'yaml',
  };
  return langMap[ext] || ext;
}

// --------------------------------------------------------------------------
// Error Parsing - Extract file path and line number from error messages
// --------------------------------------------------------------------------

export function parseErrorMessage(errorText: string): {
  filePath?: string;
  lineNumber?: number;
  columnNumber?: number;
  errorMessage: string;
} {
  // Common error patterns
  const patterns = [
    // TypeScript/JavaScript: "src/app/page.tsx(15,3): error TS..."
    /([^\s:]+\.[jt]sx?)\((\d+),(\d+)\):\s*(.+)/,
    // ESLint/Standard: "src/app/page.tsx:15:3: ..."
    /([^\s:]+\.[jt]sx?):(\d+):(\d+):\s*(.+)/,
    // Python: 'File "path.py", line 15'
    /File\s+"([^"]+)",\s+line\s+(\d+)/,
    // Go: "path.go:15:3: ..."
    /([^\s:]+\.go):(\d+):(\d+):\s*(.+)/,
    // Rust: "--> src/main.rs:15:3"
    /-->\s*([^\s:]+):(\d+):(\d+)/,
    // Generic: "at path:line:col" or "in path on line X"
    /at\s+([^\s:]+):(\d+)(?::(\d+))?/,
    /in\s+([^\s]+)\s+on\s+line\s+(\d+)/,
  ];

  for (const pattern of patterns) {
    const match = errorText.match(pattern);
    if (match) {
      return {
        filePath: match[1],
        lineNumber: parseInt(match[2], 10),
        columnNumber: match[3] ? parseInt(match[3], 10) : undefined,
        errorMessage: match[4] || errorText,
      };
    }
  }

  return { errorMessage: errorText };
}



==================================================
FILE: ./src/types/index.ts
==================================================
// ============================================================================
// TYPES - Claude Coder
// All TypeScript interfaces and types
// ============================================================================

// ----------------------------------------------------------------------------
// Chat & Message Types
// ----------------------------------------------------------------------------

export interface Message {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
  cost?: number;
  savedPercent?: number;
  tokensUsed?: TokenUsage;
  filesChanged?: FileChange[];
  files?: UploadedFile[];
  isStreaming?: boolean;
  thinkingContent?: string;
  artifacts?: Artifact[];
  citations?: Citation[];
}

export interface TokenUsage {
  input: number;
  output: number;
  cacheRead?: number;
  cacheWrite?: number;
}

export interface FileChange {
  path: string;
  action: 'create' | 'edit' | 'delete';
  additions?: number;
  deletions?: number;
  diff?: string;
}

export interface UploadedFile {
  name: string;
  type: string;
  size: number;
  base64: string;
}

// ----------------------------------------------------------------------------
// Artifact Types
// ----------------------------------------------------------------------------

export interface Artifact {
  id: string;
  name: string;
  type: ArtifactType;
  content: string;
  language?: string;
}

export type ArtifactType = 
  | 'code'
  | 'markdown'
  | 'html'
  | 'svg'
  | 'mermaid'
  | 'react';

// ----------------------------------------------------------------------------
// Conversation & Session Types
// ----------------------------------------------------------------------------

export interface Conversation {
  id: string;
  title: string;
  messages: Message[];
  createdAt: Date;
  updatedAt: Date;
  repoOwner?: string;
  repoName?: string;
  branch?: string;
  totalCost?: number;
  filesChanged?: FileChange[];
  isComplete?: boolean;
}

export interface Session {
  id: string;
  title: string;
  repoOwner: string;
  repoName: string;
  branch: string;
  date: Date;
  filesChanged: FileChange[];
  totalAdditions: number;
  totalDeletions: number;
  isComplete: boolean;
  prUrl?: string;
  prNumber?: number;
}

// ----------------------------------------------------------------------------
// GitHub Types
// ----------------------------------------------------------------------------

export interface RepoFile {
  path: string;
  content: string;
  sha: string;
}

export interface RepoTree {
  path: string;
  type: 'file' | 'dir';
  children?: RepoTree[];
}

export interface Branch {
  name: string;
  sha: string;
  isDefault: boolean;
}

export interface Repository {
  owner: string;
  name: string;
  fullName: string;
  defaultBranch: string;
  isPrivate: boolean;
}

export interface PullRequest {
  number: number;
  url: string;
  title: string;
  state: 'open' | 'closed' | 'merged';
  branch: string;
}

// ----------------------------------------------------------------------------
// Settings Types
// ----------------------------------------------------------------------------

export type WebSearchMode = 'off' | 'manual' | 'auto';

export interface Settings {
  // Deployment
  deployMode: 'safe' | 'direct';

  // Model
  model: ModelType;
  effort: EffortLevel;

  // Features
  enableWebSearch: boolean;
  webSearchMode: WebSearchMode;
  webSearchAutoDetect: boolean; // Legacy - use webSearchMode instead
  enableExtendedThinking: boolean;
  thinkingBudget: number;
  enableContextCompaction: boolean;
  enableCodeExecution: boolean;
  enableMemory: boolean;
  enableInterleavedThinking: boolean;
  enableFilesApi: boolean;

  // Budget
  tokenBudget: {
    enabled: boolean;
    perMessage: number;
    perDay: number;
  };
}

// ----------------------------------------------------------------------------
// Citation Type (for web search results)
// ----------------------------------------------------------------------------

export interface Citation {
  url: string;
  title?: string;
  snippet?: string;
  startIndex: number;
  endIndex: number;
}

export type ModelType = 
  | 'claude-sonnet-4-5-20250929'
  | 'claude-opus-4-5-20251101'
  | 'claude-haiku-4-5-20251001';

export type EffortLevel = 'low' | 'medium' | 'high';

// ----------------------------------------------------------------------------
// Cost Tracking Types
// ----------------------------------------------------------------------------

export interface CostTracker {
  sessionCost: number;
  dailyCost: number;
  monthlyCost: number;
  tokensUsed: TokenUsage;
}

export interface MessageCost {
  inputCost: number;
  outputCost: number;
  cacheReadCost: number;
  cacheWriteCost: number;
  totalCost: number;
  savedPercent: number;
}

// ----------------------------------------------------------------------------
// API Types
// ----------------------------------------------------------------------------

export interface ChatRequest {
  messages: Array<{ role: 'user' | 'assistant'; content: string }>;
  settings: Settings;
  repoContext: {
    owner: string;
    repo: string;
    branch: string;
    fileTree?: string;
    loadedFiles?: RepoFile[];
  };
  files?: UploadedFile[];
}

export interface ChatResponse {
  content: string;
  toolCalls?: ToolCall[];
  usage: TokenUsage;
  cost: number;
  savedPercent: number;
  thinkingContent?: string;
  artifacts?: Artifact[];
}

export interface ToolCall {
  id: string;
  name: string;
  input: Record<string, unknown>;
}

// ----------------------------------------------------------------------------
// Post-Edit Action Types
// ----------------------------------------------------------------------------

export interface PostEditState {
  mode: 'safe' | 'direct';
  branch?: string;
  filesChanged: FileChange[];
  totalAdditions: number;
  totalDeletions: number;
  prUrl?: string;
  prNumber?: number;
  previewUrl?: string;
  status: 'pending' | 'pushed' | 'pr_created' | 'confirmed' | 'discarded';
}

// ----------------------------------------------------------------------------
// UI State Types
// ----------------------------------------------------------------------------

export interface AppState {
  // Auth
  isAuthenticated: boolean;
  
  // UI
  darkMode: boolean;
  sidebarOpen: boolean;
  settingsOpen: boolean;
  artifactPanelOpen: boolean;
  
  // Active states
  currentConversationId: string | null;
  currentRepo: Repository | null;
  currentBranch: string;
  
  // Loading states
  isLoading: boolean;
  isStreaming: boolean;
}

// ----------------------------------------------------------------------------
// Tool Types for Claude
// ----------------------------------------------------------------------------

export interface ClaudeTool {
  name: string;
  description: string;
  input_schema: {
    type: 'object';
    properties: Record<string, ToolProperty>;
    required: string[];
  };
}

export interface ToolProperty {
  type: string;
  description: string;
  enum?: string[];
}

// ----------------------------------------------------------------------------
// Default Values
// ----------------------------------------------------------------------------

export const DEFAULT_SETTINGS: Settings = {
  deployMode: 'safe',
  model: 'claude-sonnet-4-5-20250929',
  effort: 'medium',
  enableWebSearch: true,
  webSearchMode: 'auto',
  webSearchAutoDetect: true, // Legacy
  enableExtendedThinking: false,
  thinkingBudget: 10000,
  enableContextCompaction: true,
  enableCodeExecution: false,
  enableMemory: true,
  enableInterleavedThinking: false,
  enableFilesApi: false,
  tokenBudget: {
    enabled: true,
    perMessage: 0.50,
    perDay: 10.0,
  },
};

// ----------------------------------------------------------------------------
// Model Pricing (per million tokens) - Per Anthropic API docs
// ----------------------------------------------------------------------------

export const MODEL_PRICING: Record<ModelType, { input: number; output: number; cacheRead: number; cacheWrite: number }> = {
  'claude-sonnet-4-5-20250929': {
    input: 3.00,      // $3/M input
    output: 15.00,    // $15/M output
    cacheRead: 0.30,  // 90% off = $0.30/M
    cacheWrite: 3.75, // 25% more = $3.75/M
  },
  'claude-opus-4-5-20251101': {
    input: 15.00,     // $15/M input
    output: 75.00,    // $75/M output
    cacheRead: 1.50,  // 90% off = $1.50/M
    cacheWrite: 18.75,// 25% more = $18.75/M
  },
  'claude-haiku-4-5-20251001': {
    input: 1.00,      // $1/M input (corrected from $0.80)
    output: 5.00,     // $5/M output (corrected from $4.00)
    cacheRead: 0.10,  // 90% off = $0.10/M
    cacheWrite: 1.25, // 25% more = $1.25/M
  },
};

// Model display names for UI
export const MODEL_DISPLAY_NAMES: Record<ModelType, { name: string; cost: string; description: string }> = {
  'claude-haiku-4-5-20251001': {
    name: 'Haiku 4.5',
    cost: '',
    description: 'Fastest',
  },
  'claude-sonnet-4-5-20250929': {
    name: 'Sonnet 4.5',
    cost: '',
    description: 'Default',
  },
  'claude-opus-4-5-20251101': {
    name: 'Opus 4.5',
    cost: '',
    description: 'Best',
  },
};



==================================================
FILE: ./tsconfig.json
==================================================
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}



